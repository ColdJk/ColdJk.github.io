<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Comic Sans MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"senkorl.xyz","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="16 | “order by”是怎么工作的？假设部分表定义： 12345678910CREATE TABLE &#96;t&#96; (  &#96;id&#96; int(11) NOT NULL,  &#96;city&#96; varchar(16) NOT NULL,  &#96;name&#96; varchar(16) NOT NULL,  &#96;age&#96; int(11) NOT NULL,  &#96;addr&#96; varchar(128) DEFAUL">
<meta property="og:type" content="article">
<meta property="og:title" content="「MySQL45讲」16-30讲">
<meta property="og:url" content="https://senkorl.xyz/mysql/mysql45-2/index.html">
<meta property="og:site_name" content="Senkorl">
<meta property="og:description" content="16 | “order by”是怎么工作的？假设部分表定义： 12345678910CREATE TABLE &#96;t&#96; (  &#96;id&#96; int(11) NOT NULL,  &#96;city&#96; varchar(16) NOT NULL,  &#96;name&#96; varchar(16) NOT NULL,  &#96;age&#96; int(11) NOT NULL,  &#96;addr&#96; varchar(128) DEFAUL">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181222153425137.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181222153640785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181222154532776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2018122216040612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181222161521159.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181222165226255.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181222171056417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181222171611376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181226215209599.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181226220610765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019012520465313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190125205012202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190125212120506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190125212653635.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190125213015634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190126160046657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019012616034191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190126162140869.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190126162404243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190126162846523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019012616335658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190126165506629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190126184905259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190126185605299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190126190150658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190217162322782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190224144019294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019022414520599.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190224152550874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019022415380793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019022416443224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190224175055777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190224180622724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190224181715899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190224181747208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190224182017655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190224182324907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2020-02-29T04:02:05.000Z">
<meta property="article:modified_time" content="2020-02-29T04:02:05.000Z">
<meta property="article:author" content="Senkorl">
<meta property="article:tag" content="MySQL45讲">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20181222153425137.png">

<link rel="canonical" href="https://senkorl.xyz/mysql/mysql45-2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>「MySQL45讲」16-30讲 | Senkorl</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Senkorl</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">专注于最有价值的事情.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/myhome/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://senkorl.xyz/mysql/mysql45-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Senkorl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Senkorl">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          「MySQL45讲」16-30讲
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-29 12:02:05" itemprop="dateCreated datePublished" datetime="2020-02-29T12:02:05+08:00">2020-02-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <meta name="referrer" content="no-referrer">


<h2 id="16-“order-by”是怎么工作的？"><a href="#16-“order-by”是怎么工作的？" class="headerlink" title="16 | “order by”是怎么工作的？"></a>16 | “order by”是怎么工作的？</h2><p>假设部分表定义：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `city` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `addr` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `city` (`city`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p>假设按照下面的sql查询并排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city,name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>  ;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><p>explain<br><img src="https://img-blog.csdnimg.cn/20181222153425137.png" alt="在这里插入图片描述"><br>Extra中”Using filesort”表示排序，mysql会给<strong>每个线程</strong>分配一个块内存（sort_buffer）用来排序。<br>city索引示意图：<br><img src="https://img-blog.csdnimg.cn/20181222153640785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>sql执行过程：</p>
<ol>
<li>初始化sort_buffer，确定放入name、city、age 这三个字段；</li>
<li>从city索引找到第一个city=’杭州’的主键id，图中的ID_X；</li>
<li>根据id去聚集索引取这三个字段，放到sort_buffer；</li>
<li>在从city索引取下一个；</li>
<li>重复3、4查询所有的值；</li>
<li>在sort_buffer按name快速排序；</li>
<li>按照排序结果取前1000行返回给客户端。</li>
</ol>
<p>如果sort_buffer太小，内存放不下排序的数据，则需要使用外部排序，利用磁盘临时文件辅助排序。这取决于排序所需内存和参数 sort_buffer_size。<br>下面方法可以确定排序是否使用临时文件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打开 optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>; </span><br><span class="line"><span class="comment">/* @a 保存 Innodb_rows_read 的初始值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@a</span> <span class="keyword">from</span>  performance_schema.session_status <span class="keyword">where</span> variable_name <span class="operator">=</span> <span class="string">&#x27;Innodb_rows_read&#x27;</span>;</span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> city, name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>; </span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `information_schema`.`OPTIMIZER_TRACE`\G</span><br><span class="line"><span class="comment">/* @b 保存 Innodb_rows_read 的当前值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@b</span> <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name <span class="operator">=</span> <span class="string">&#x27;Innodb_rows_read&#x27;</span>;</span><br><span class="line"><span class="comment">/* 计算 Innodb_rows_read 差值 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@b</span><span class="operator">-</span><span class="variable">@a</span>;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20181222154532776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通过查看 OPTIMIZER_TRACE，number_of_tmp_files表示排序使用的临时文件数，外部排序一般使用<strong>归并排序算法</strong>。<br>rows表示满足city=’杭州’有4000条，examined_rows=4000表示4000行参与排序。<br>sort_mode packed_additional_fields表示排序过程字符串做了“紧凑”处理。name字段定义varchar(16)，排序过程中按照实际长度分配空间。<br>最后一个查询语句 select @b-@a返回结果是 4000，表示只扫描了4000行。</p>
<p>这边老师把internal_tmp_disk_storage_engine 设置成MyISAM，否则，select @b-@a结果为 4001。因为innodb把数据从临时表取出来时，会让Innodb_rows_read 的值加 1。</p>
<h3 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h3><p>如果排序的单行长度太大mysql会使用另一种算法。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> max_length_for_sort_data <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>city、name、age 这三个字段的定义总长度是 36 &gt; max_length_for_sort_data，所以会使用别的算法。<br>该算法和全字段排序的差别：</p>
<ol>
<li>sort_buffer只会确定放入name 和 id字段，所以只会取这两个字段。</li>
<li>最后根据name排完序，会根据id字段去原表取city、name 和 age 三个字段返回给客户端。</li>
</ol>
<p><strong>需要注意，不做合并操作，而是直接将原表查到的字段返回给客户端。</strong><br>和上述过程对比：<br><img src="https://img-blog.csdnimg.cn/2018122216040612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>examined_rows和rows没有变化，但select @b-@a会变成5000。因为排完序需要去原表再取1000行。</p>
<h3 id="全字段排序-VS-rowid-排序"><a href="#全字段排序-VS-rowid-排序" class="headerlink" title="全字段排序 VS rowid 排序"></a>全字段排序 VS rowid 排序</h3><p>对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。<br>假设从city索引上取出来的行<strong>天然按照name递增排序，就不需要再进行排序了</strong>。<br>所以可以建一个city和name的<strong>联合索引</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> index city_user(city, name);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>整个查询流程就变成了：</p>
<ol>
<li>从索引(city, name)找到第一个city=’杭州’的主键id；</li>
<li>到聚集索引取name、city、age三个字段，作为结果集一部分直接返回；</li>
<li>从索引(city, name)取下一个。</li>
<li>重复2、3，直到查到1000条记录，或不满足city=’杭州’时结束。</li>
</ol>
<p>explian:<br><img src="https://img-blog.csdnimg.cn/20181222161521159.png" alt="在这里插入图片描述"><br>没有”Using filesort”。<br>使用<a target="_blank" rel="noopener" href="https://blog.csdn.net/zxcc1314/article/details/85216128#no5.index"><strong>覆盖索引</strong></a>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> index city_user_age(city, name, age);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>但维护索引是有代价的，所以需要权衡。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> city <span class="keyword">in</span> (<span class="string">&#x27;杭州&#x27;</span>,&quot; 苏州 &quot;) <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">100</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>上述sql需要排序，因为name不是递增的。<br>可以将sql拆分成两条，最后通过程序内存取前100条。<br>进一步，如果需要分页，“limit 10000,100”，则可以使用下面的思想：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span>&quot; 杭州 &quot; <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">10100</span>; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span>&quot; 苏州 &quot; <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">10100</span>。</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>根据，name排序，然后取10001~10100，但这样返回的数据量较大，所以可以改成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span>&quot; 杭州 &quot; <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">10100</span>; </span><br><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span>&quot; 苏州 &quot; <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">10100</span>。</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>根据，name排序，然后取10001~10100，然后在通过id查询100条数据。</p>
<h3 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h3><p>评论区大神多，特别是@某、人，看到好多次了。下面是他的回答：<br><strong>问题一</strong> ：这种无条件查列表页除了全表扫还有其他建立索引的办法么<br>1)无条件查询如果只有order by create_time,即便create_time上有索引,也不会使用到。<br>因为优化器认为走二级索引再去回表成本比全表扫描排序更高。<br>所以选择走全表扫描,然后根据老师讲的两种方式选择一种来排序<br>2)无条件查询但是是order by create_time limit m.如果m值较小,是可以走索引的.<br>因为优化器认为根据索引有序性去回表查数据,然后得到m条数据,就可以终止循环,那么成本比全表扫描小,则选择走二级索引。<br>即便没有二级索引,mysql针对order by limit也做了优化,采用堆排序。这部分老师明天会讲<br><strong>问题二</strong> : 如果加入 group by ， 数据该如何走<br>如果是group by a,a上不能使用索引的情况,是走rowid排序。<br>如果是group by limit,不能使用索引的情况,是走堆排序<br>如果是只有group by a,a上有索引的情况,又根据选取值不同,索引的扫描方式又有不同<br>select * from t group by a –走的是索引全扫描,至于这里为什么选择走索引全扫描,还需要老师解惑下<br>select a from t group by a –走的是索引松散扫描,也就说只需要扫描每组的第一行数据即可,不用扫描每一行的值<br><strong>问题三</strong> ：老师之后的文章会有讲解 bigInt(20) 、 tinyint(2) 、varchar(32) 这种后面带数字与不带数字有何区别的文章么 。 每次建字段都会考虑长度 ，但实际却不知道他有何作用<br>bigint和int加数字都不影响能存储的值。<br>bigint(1)和bigint(19)都能存储2^64-1范围内的值,int是 2^32-1。只是有些前端会根据括号里来截取显示而已。建议不加varchar()就必须带,因为varchar()括号里的数字代表能存多少字符。假设varchar(2),就只能存两个字符,不管是中文还是英文。目前来看varchar()这个值可以设得稍稍大点,因为内存是按照实际的大小来分配内存空间的,不是按照值来预分配的。</p>
<h2 id="17-如何正确地显示随机消息？"><a href="#17-如何正确地显示随机消息？" class="headerlink" title="17 | 如何正确地显示随机消息？"></a>17 | 如何正确地显示随机消息？</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `words` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `word` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">  while i<span class="operator">&lt;</span><span class="number">10000</span> do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> words(word) <span class="keyword">values</span>(concat(<span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i div <span class="number">1000</span>)), <span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i <span class="operator">%</span> <span class="number">1000</span> div <span class="number">100</span>)), <span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i <span class="operator">%</span> <span class="number">100</span> div <span class="number">10</span>)), <span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i <span class="operator">%</span> <span class="number">10</span>))));</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure>

<p>需求：每次随机获取三个word；</p>
<h3 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>explain:<br><img src="https://img-blog.csdnimg.cn/20181222165226255.png" alt="在这里插入图片描述"><br>这个 Extra 的意思就是，需要临时表，并且需要在临时表上排序。<br>上一篇文章的一个结论：对于 InnoDB 表来说，执行全字段排序会减少磁盘访问，因此会被优先选择。<br><strong>对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘。</strong>所以，MySQL 这时就会选择 rowid 排序。<br>上述sql的执行流程：</p>
<ol>
<li>创建一个memory引擎的临时表，第一个字段double类型，假设字段为R，第二个字段varchar(64)，记为字段W。并且这个表没有索引。</li>
<li>从 words 表中，按主键顺序取出所有的 word 值。对于每一个 word 值，调用 rand() 函数生成一个大于 0 小于 1 的随机小数，并把这个随机小数和 word分别存入临时表的 R 和 W 字段中，到此，扫描行数是 10000。</li>
<li>接着在没有索引的内存临时表上，按字段R排序。</li>
<li>初始化sort_buffer。sort_buffer和临时表一直两个字段。</li>
<li>临时表全表扫描去取R值和位置信息（稍后解释），放入sort_buffer两个字段，此时扫描行数增加10000，变成20000。</li>
<li>在sort_buffer对R值排序。</li>
<li>排序完成取前三行，总扫描行数变成20003行。</li>
</ol>
<p>通过慢查询日志（slow log）可以看到</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Query_time: <span class="number">0.900376</span>  Lock_time: <span class="number">0.000347</span> Rows_sent: <span class="number">3</span> Rows_examined: <span class="number">20003</span></span><br><span class="line"><span class="keyword">SET</span> <span class="type">timestamp</span><span class="operator">=</span><span class="number">1541402277</span>;</span><br><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>流程图如下，图中的pos就是位置信息，类似主键id：<br><img src="https://img-blog.csdnimg.cn/20181222171056417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h3><p>tmp_table_size限制了内存临时表的大小，默认16M。如果内存大于tmp_table_size，则会转成磁盘临时表。<br>磁盘临时表使用的引擎默认是 InnoDB，由参数 internal_tmp_disk_storage_engine 控制。<br>复现：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> tmp_table_size<span class="operator">=</span><span class="number">1024</span>;</span><br><span class="line"><span class="keyword">set</span> sort_buffer_size<span class="operator">=</span><span class="number">32768</span>;</span><br><span class="line"><span class="keyword">set</span> max_length_for_sort_data<span class="operator">=</span><span class="number">16</span>;</span><br><span class="line"><span class="comment">/* 打开 optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>; </span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `information_schema`.`OPTIMIZER_TRACE`\G</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p>部分PTIMIZER_TRACE 的结果如下：<br><img src="https://img-blog.csdnimg.cn/20181222171611376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于max_length_for_sort_data 设置成 16，所以参与排序的是R字段和row_id字段组成的行。<br>R字段8个字节，rowid是6个字节，总行数10000，这样总共140000字节，超过sort_buffer_size，但没有使用临时文件。<br>是因为MySQL 5.6 版本引入的一个新的排序算法，即：优先队列排序算法。<br>因为sql只需要去R值最小的3个rowid，所以不需要将所有的数据排序，所以没有使用临时文件（归并排序算法）。</p>
<p>优先级队列算法执行流程如下：</p>
<ol>
<li>先取前三行，构造成一个堆。</li>
<li>取下一行(R’,rowid’)，跟当前堆最大的R比较，如果 R’小于 R，把这个 (R,rowid)从堆中去掉，换成 (R’,rowid’)；</li>
<li>重复第 2 步，直到第 10000 个 (R’,rowid’) 完成比较。</li>
</ol>
<p>上图OPTIMIZER_TRACE 结果中，filesort_priority_queue_optimization 这个部分的chosen=true，就表示使用了优先队列排序算法。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city,name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这句sql没有使用优先队列排序算法，因为limit 1000堆大小超过了sort_buffer_size 大小。</p>
<h3 id="随机排序方法"><a href="#随机排序方法" class="headerlink" title="随机排序方法"></a>随机排序方法</h3><p>随机选取一个word值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">max</span>(id),<span class="built_in">min</span>(id) <span class="keyword">into</span> <span class="variable">@M</span>,<span class="variable">@N</span> <span class="keyword">from</span> t ;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@X</span><span class="operator">=</span> <span class="built_in">floor</span>((<span class="variable">@M</span><span class="operator">-</span><span class="variable">@N</span><span class="operator">+</span><span class="number">1</span>)<span class="operator">*</span>rand() <span class="operator">+</span> <span class="variable">@N</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="variable">@X</span> limit <span class="number">1</span>;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>取 max(id) 和 min(id) 都是不需要扫描索引，而第三步的 select 也可以用索引快速定位，可以认为就只扫描了3行。<br>但id中间可能有空洞，所以不同行概率不一样。<br>所以，为了得到严格随机的结果，你可以用下面这个流程:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="variable">@C</span> <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@sql</span> <span class="operator">=</span> concat(&quot;select * from t limit &quot;, <span class="variable">@Y</span>, &quot;,1&quot;);</span><br><span class="line"><span class="keyword">prepare</span> stmt <span class="keyword">from</span> <span class="variable">@sql</span>;</span><br><span class="line"><span class="keyword">execute</span> stmt;</span><br><span class="line"><span class="keyword">DEALLOCATE</span> <span class="keyword">prepare</span> stmt;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>MySQL 处理 limit Y,1 的做法就是按顺序一个一个地读出来，丢掉前 Y 个，然后把下一个记录作为返回结果，此这一步需要扫描 Y+1 行。<br>再加上，第一步扫描的 C 行，总共需要扫描 C+Y+1 行，执行代价比第一个随机算法的代价要高。<br>另外一个思路：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="variable">@C</span> <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y1</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y2</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y3</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y1</span>，<span class="number">1</span>； <span class="operator">/</span><span class="operator">/</span> 在应用代码里面取 Y1、Y2、Y3 值，拼出 <span class="keyword">SQL</span> 后执行</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y2</span>，<span class="number">1</span>；</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y3</span>，<span class="number">1</span>；</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<h2 id="18-为什么这些SQL语句逻辑相同，性能却差异巨大？"><a href="#18-为什么这些SQL语句逻辑相同，性能却差异巨大？" class="headerlink" title="18 | 为什么这些SQL语句逻辑相同，性能却差异巨大？"></a>18 | 为什么这些SQL语句逻辑相同，性能却差异巨大？</h2><h3 id="案例一：条件字段函数操作"><a href="#案例一：条件字段函数操作" class="headerlink" title="案例一：条件字段函数操作"></a>案例一：条件字段函数操作</h3><p>不要对字段进行计算。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">month</span>(t_modified)<span class="operator">=</span><span class="number">7</span>;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<h3 id="案例二：隐式类型转换"><a href="#案例二：隐式类型转换" class="headerlink" title="案例二：隐式类型转换"></a>案例二：隐式类型转换</h3><p>数据类型与字段类型不同的，将导致全表扫描。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>判断mysql怎么进行数据类型转换，下面的字符串会转成数字，返回<span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> “<span class="number">10</span>” <span class="operator">&gt;</span> <span class="number">9</span>;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<h3 id="案例三：隐式字符编码转换"><a href="#案例三：隐式字符编码转换" class="headerlink" title="案例三：隐式字符编码转换"></a>案例三：隐式字符编码转换</h3><p>两张表编码格式不一致也会导致全表查询。</p>
<h2 id="19-为什么我只查一行的语句，也执行这么慢？"><a href="#19-为什么我只查一行的语句，也执行这么慢？" class="headerlink" title="19 | 为什么我只查一行的语句，也执行这么慢？"></a>19 | 为什么我只查一行的语句，也执行这么慢？</h2><p>本节表结构和数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">100000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i)</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>

<h3 id="第一类：查询长时间不返回"><a href="#第一类：查询长时间不返回" class="headerlink" title="第一类：查询长时间不返回"></a>第一类：查询长时间不返回</h3><p><strong>等MDL锁</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> processlist;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>或下面<span class="keyword">sql</span>，可以找出pid（设置 performance_schema<span class="operator">=</span><span class="keyword">on</span>，相比于设置为 off 会有 <span class="number">10</span><span class="operator">%</span> 左右的性能损失）</span><br><span class="line"><span class="keyword">select</span> blocking_pid <span class="keyword">from</span> sys.schema_table_lock_waits;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>等flush</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>该<span class="keyword">sql</span>可以查询到当前状态</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.processlist <span class="keyword">where</span> id<span class="operator">=</span> <span class="string">&#x27;pid&#x27;</span>;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>如果查到如下图所示，则表示有线程正要对表进行flush操作。<br><img src="https://img-blog.csdnimg.cn/20181226215209599.png" alt="在这里插入图片描述"><br>MySQL 里面对表做 flush 操作的用法，一般有以下两个：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flush tables t <span class="keyword">with</span> read lock;</span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p><strong>等行锁</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t sys.innodb_lock_waits <span class="keyword">where</span> locked_table<span class="operator">=</span>table_name \G</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>KILL pid 断开连接，隐含逻辑自动回滚这个连接里面正在执行的线程，释放行锁。</p>
<h3 id="第二类：查询慢"><a href="#第二类：查询慢" class="headerlink" title="第二类：查询慢"></a>第二类：查询慢</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c<span class="operator">=</span><span class="number">50000</span> limit <span class="number">1</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如果字段c上没有索引，这个语句只能走id主键顺序扫描，需要扫描5万行。<br><strong>扫描一行却很慢的语句</strong><br><img src="https://img-blog.csdnimg.cn/20181226220610765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>session B执行100万次后，生成了100万个undo log，所以第一个select 快照读要将undo log执行100万次回到快照的版本。而第二个select当前读。</p>
<p>最后，老师提了for update加锁，关于各隔离级别加锁情况<a target="_blank" rel="noopener" href="https://www.cnblogs.com/rjzheng/p/9950951.html">参考链接</a>，这个大哥写的可以。</p>
<h2 id="20-幻读是什么，幻读有什么问题？"><a href="#20-幻读是什么，幻读有什么问题？" class="headerlink" title="20 | 幻读是什么，幻读有什么问题？"></a>20 | 幻读是什么，幻读有什么问题？</h2><p>该章节大致了解，不细写。</p>
<h3 id="幻读是什么？"><a href="#幻读是什么？" class="headerlink" title="幻读是什么？"></a>幻读是什么？</h3><p>当前读，新插入的行。</p>
<h3 id="间隙锁和next-key-lock"><a href="#间隙锁和next-key-lock" class="headerlink" title="间隙锁和next-key lock"></a>间隙锁和next-key lock</h3><p>innodb为了解决幻读加入了间隙锁，锁住一个索引区间(开区间)。<br>锁住索引记录的区间，或第一条索引记录之前的范围，或者最后一条索引记录之后的范围。</p>
<p>间隙锁和行锁合成next-key lock，前开后闭区间。</p>
<p>如下，间隙锁的引入容易导致死锁。<br>因为select for update会加入间隙锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span>N <span class="keyword">for</span> update;</span><br><span class="line"><span class="comment">/* 如果行不存在 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(N,N,N);</span><br><span class="line"><span class="comment">/* 如果行存在 */</span></span><br><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span>N <span class="keyword">set</span> id<span class="operator">=</span>N;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>如果业务可以容忍可重复读，可使用重复读+binlog 格式设置为 row，可重复读没有间隙锁。</strong></p>
<h2 id="21-为什么我只改一行的语句，锁这么多？"><a href="#21-为什么我只改一行的语句，锁这么多？" class="headerlink" title="21 | 为什么我只改一行的语句，锁这么多？"></a>21 | 为什么我只改一行的语句，锁这么多？</h2><p>文章基于可重复读，读提交就是去掉间隙锁。<br>老师的总结，很好：<br>两个“原则”、两个“优化”和一个“bug”</p>
<ol>
<li>原则 1：加锁的基本单位是next-key lock。</li>
<li>原则 2：查找过程中访问到的对象才会加锁。</li>
<li>优化1：索引等值查询，唯一索引，行锁。</li>
<li>优化2：索引等值查询，向右遍历且最后一个值不满足等值条件时，next-key lock 退化为间隙锁。</li>
<li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ol>
<p><strong>limit加锁</strong><br>limit删除数据时，只会扫描limit行数，不会继续扫描，所以加锁粒度更小。<br><strong>在删除数据时，尽量加limit。</strong></p>
<h2 id="22-MySQL有哪些“饮鸩止渴”提高性能的方法？"><a href="#22-MySQL有哪些“饮鸩止渴”提高性能的方法？" class="headerlink" title="22 | MySQL有哪些“饮鸩止渴”提高性能的方法？"></a>22 | MySQL有哪些“饮鸩止渴”提高性能的方法？</h2><h3 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h3><p>max_connections<br>wait_timeout 参数，一个线程空闲这么多秒后自动断开连接。</p>
<ul>
<li>断开占着连接不工作线程，先考虑事务外进程。<strong>服务端主动断开连接，客户端不一定能正确处理。</strong></li>
<li>减少连接过程的消耗，–skip-grant-tables 参数，不安全。</li>
</ul>
<h3 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h3><ul>
<li>索引问题<br>建索引<br>主备架构，先增加备库索引。更新前执行set sql_log_bin=off。</li>
<li>语句问题</li>
<li>qps突增问题</li>
</ul>
<h2 id="23-MySQL是怎么保证数据不丢的？"><a href="#23-MySQL是怎么保证数据不丢的？" class="headerlink" title="23 | MySQL是怎么保证数据不丢的？"></a>23 | MySQL是怎么保证数据不丢的？</h2><h3 id="binlog写入机制"><a href="#binlog写入机制" class="headerlink" title="binlog写入机制"></a>binlog写入机制</h3><p>事务执行，把日志写到binlog cache，事务提交，把binlog cache写到binlog文件中，binlog不同事务分头写，所以不需要锁。<br>一个事务的binlog不能被拆开。<br>每个线程分配一个binlog cache，binlog_cache_size控制，超过这个参数要暂存磁盘。<br><img src="https://img-blog.csdnimg.cn/2019012520465313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上图说明事务提交时，执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空binlog cache。<br>图中的write只是写文件系统的page cache。</p>
<p>write 和 fsync 的时机，是由参数 sync_binlog 控制的：</p>
<ol>
<li>sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync；</li>
<li>sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；</li>
<li>sync_binlog=N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ol>
<h3 id="redo-log写入机制"><a href="#redo-log写入机制" class="headerlink" title="redo log写入机制"></a>redo log写入机制</h3><p><img src="https://img-blog.csdnimg.cn/20190125205012202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>redo log buffer不需要每次都持久化硬盘，mysql异常重启，这部分日志就会丢失。<br>未提交的事务可能会被持久化到硬盘。</p>
<p>关于控制刷盘的innodb_flush_log_at_trx_commit参数，在02 | 日志系统：一条SQL更新语句是如何执行的中提到过。<br>Innodb还有一个后台线程，每隔一秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的件系统的 page cache，然后调用 fsync 持久化到磁盘。</p>
<p>除了后台线程每秒一次的轮询，还有两个场景会让一个没有提交的事务的redo log刷盘。</p>
<ol>
<li>当redo log buffer占用空间即将达到innodb_log_buffer_size一半时，后台线程会主动刷盘。该动作只是写到page cache。</li>
<li>并行事务提交时，会顺带刷盘。A事务写了一些redo log buffer，另一个事务B提交，innodb_flush_log_at_trx_commit=1，所以事务B要把redo log buffer的日志全部刷盘。这时会把事务A在redo log buffer日志一起刷盘。</li>
</ol>
<p>如果把innodb_flush_log_at_trx_commit设置成1，redo log在prepare需持久化一次，所以在15 | 答疑文章（一）：日志和索引相关问题中，提到redo log 已经prepare，并且已经写完binlog就可以异常恢复。</p>
<p>每秒一次后台轮询刷盘，再加上崩溃恢复的逻辑，InnoDB 就认为 redo log 在 commit 的时候就不需要 fsync 了，只会 write 到文件系统的 page cache 中就够了。</p>
<p><strong>组提交（group commit）机制</strong><br>日志逻辑序列号（log sequence number，LSN）是单调递增的，用来对应 redo log 的写入点。每次写入长度为 length 的 redo log，LSN 的值就会加上 length。<br>LSN 也会写到 InnoDB 的数据页中，来确保数据页不会被多次执行重复的 redo log。<br><img src="https://img-blog.csdnimg.cn/20190125212120506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上图三个并发事务（trx1，trx2，trx3）在prepare阶段写完redo log buffer，持久化到磁盘的过程，对应的 LSN 分别是 50、120 和 160。当trx1开始刷盘，trx1会被选为leader，这个组有三个事务，这时LSN变成160，trx1写盘时会把LSN小于160的redo log都持久化，这时trx2和trx3可以直接返回。<br><img src="https://img-blog.csdnimg.cn/20190125212653635.png" alt="在这里插入图片描述"><br>实际上write是两步，如下图。<br><img src="https://img-blog.csdnimg.cn/20190125213015634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>所以binlog也可以组提交，不过通常情况第三步执行较快，binlog组提交效果较差。所以可以优化以下两个参数。</p>
<ol>
<li>binlog_group_commit_sync_delay参数，表示延迟多少微秒后才调用 fsync;</li>
<li>binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用 fsync。</li>
</ol>
<p>不建议将innodb_flush_log_at_trx_commit设置成0，设置成2只是多一个写page cache，效率相差不大，但2在mysql异常重启不会丢数据，只在主机掉电才会丢数据。</p>
<p>如果 binlog 写完盘以后发生 crash，这时候还没给客户端答复就重启了。等客户端再重连进来，发现事务已经提交成功了，这不是 bug。<br>数据库的 crash-safe 保证的是：</p>
<ol>
<li>如果客户端收到事务成功的消息，事务就一定持久化了；</li>
<li>如果客户端收到事务失败（比如主键冲突、回滚等）的消息，事务就一定失败了；</li>
<li>如果客户端收到“执行异常”的消息，应用需要重连后通过查询当前状态来继续后续的逻辑。此时数据库只需要保证内部（数据和日志之间，主库和备库之间）一致就可以了。</li>
</ol>
<p>关于1应该是不一定的。<br>两个留言：<br>sync_binlog = N：每个事务write后就响应客户端了。刷盘是N次事务后刷盘。N次事务之间宕机，数据丢失。<br>binlog_group_commit_sync_no_delay_count=N： 必须等到N个后才能提交。换言之，会增加响应客户端的时间。但是一旦响应了，那么数据就一定持久化了。宕机的话，数据是不会丢失的。</p>
<p>innodb的 redo log 在commit的时候不进行fsync，只会write 到page cache中。当sync_binlog&gt;1,如果redo log 完成了prepare持久化落盘，binlog只是write page cache，此时commit标识完成write 但没有落盘，而client收到commit成功，这个时候主机掉电，启动的时候做崩溃恢复，没有commit标识和binglog，事务会回滚。sync_binlog设置为大于1的值，会丢binlog日志,此时数据也会丢失。</p>
<h2 id="24-MySQL是怎么保证主备一致的？"><a href="#24-MySQL是怎么保证主备一致的？" class="headerlink" title="24 | MySQL是怎么保证主备一致的？"></a>24 | MySQL是怎么保证主备一致的？</h2><h3 id="MySQL-主备的基本原理"><a href="#MySQL-主备的基本原理" class="headerlink" title="MySQL 主备的基本原理"></a>MySQL 主备的基本原理</h3><p><img src="https://img-blog.csdnimg.cn/20190126160046657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>将备库设置成read only防止双写情况方式。read only对超级权限用户无效，所以可以同步。<br><img src="https://img-blog.csdnimg.cn/2019012616034191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上图展示了update主从同步的过程。</p>
<h3 id="binlog-的三种格式对比"><a href="#binlog-的三种格式对比" class="headerlink" title="binlog 的三种格式对比"></a>binlog 的三种格式对比</h3><p>表结构：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `t_modified` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `a` (`a`),</span><br><span class="line">  KEY `t_modified`(`t_modified`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;2018-11-13&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">2</span>,<span class="string">&#x27;2018-11-12&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">3</span>,<span class="string">&#x27;2018-11-11&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">4</span>,<span class="number">4</span>,<span class="string">&#x27;2018-11-10&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">5</span>,<span class="number">5</span>,<span class="string">&#x27;2018-11-09&#x27;</span>);</span><br><span class="line"><span class="number">1234567891011121314</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> t <span class="comment">/*comment*/</span>  <span class="keyword">where</span> a<span class="operator">&gt;=</span><span class="number">4</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;=</span><span class="string">&#x27;2018-11-10&#x27;</span> limit <span class="number">1</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>当 <strong>binlog_format=statement</strong> 时，binlog 里面记录的就是 SQL 语句的原文。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;master.000001&#x27;</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190126162140869.png" alt="在这里插入图片描述"><br>delete 命令的执行效果图：<br><img src="https://img-blog.csdnimg.cn/20190126162404243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>statement 格式，并且语句中有 limit，这个命令可能是 unsafe 的，可能会出现主备数据不一致。<br>比如上面那个delete：</p>
<ol>
<li>如果delete使用索引A，那么会根据索引 a 找到第一个满足条件的行，也就是说删除的是a=4 这一行；</li>
<li>但如果使用的是索引 t_modified，那么删除的就是 t_modified=’2018-11-09’也就是 a=5这一行。</li>
</ol>
<p>因为主备使用索引不一致会导致删除不同数据。</p>
<p><strong>binlog_format=‘row’</strong><br><img src="https://img-blog.csdnimg.cn/20190126162846523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>Table_map event，用于说明接下来要操作的表是test 库的表 t;</li>
<li>Delete_rows event，用于定义删除的行为。</li>
</ol>
<p>上图显示事务从8900开始，借助mysqlbinlog 工具，可以看到详细的log。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog  <span class="operator">-</span>vv data<span class="operator">/</span>master<span class="number">.000001</span> <span class="comment">--start-position=8900;</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/2019012616335658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>事务在server id 1这个库执行。</li>
<li>每个event都有crc32的值，binlog_checksum控制。</li>
<li>Table_map event表示打开的表，map到数字226，如果有多张表，每个表都有一个对应的 Table_map event、都会 map 到一个单独的数字。</li>
<li>mysqlbinlog -vv 参数是为了把内容都解析出来，所以从结果里面可以看到各个字段的值（比如，@1=4、 @2=4 这些值）。</li>
<li>binlog_row_image 的默认配置是 FULL，因此 Delete_event 里面，包含了删掉的行的所有字段的值。如果设置为 MINIMAL，只会记录 id=4 这个信息。</li>
</ul>
<p><strong>为什么会有 mixed 格式的 binlog？</strong><br>因为row格式如果删除10万行，就要记录10万条记录到binlog，会占据大量的存储空间和IO资源。<br>mixed 格式会判断sql是否会引起主备不一致，有可能，就用 row 格式，否则就用 statement 格式。</p>
<p>主流还是使用row 格式，因为该格式可以<strong>恢复数据</strong>。<br>用 binlog 来恢复数据的标准做法是，用 mysqlbinlog 工具解析出来，然后把解析结果发给整个MySQL 执行。类似下面的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog master<span class="number">.000001</span>  <span class="comment">--start-position=2738 --stop-position=2973 | mysql -h127.0.0.1 -P13000 -u$user -p$pwd;</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="循环复制问题"><a href="#循环复制问题" class="headerlink" title="循环复制问题"></a>循环复制问题</h3><p>实际生产上使用比较多的是双 M 结构。<br><img src="https://img-blog.csdnimg.cn/20190126165506629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>业务逻辑在节点 A 上更新了一条语句，然后再把生成的 binlog 发给节点 B，节点 B 执行完这条更新语句后也会生成 binlog。（参数 log_slave_updates 设置为 on，表示备库执行 relay log 后生成 binlog）。<br>下面逻辑可以解决两个节点间的循环复制的问题：</p>
<ol>
<li>规定两个库的 server id 必须不同；</li>
<li>一个备库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的 binlog；</li>
<li>每个库收到主库发来的日志，判断server id是否和自己相同，相同直接丢弃日志。</li>
</ol>
<h2 id="25-MySQL是怎么保证高可用的？"><a href="#25-MySQL是怎么保证高可用的？" class="headerlink" title="25 | MySQL是怎么保证高可用的？"></a>25 | MySQL是怎么保证高可用的？</h2><h3 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h3><ol>
<li>主库A完成事务写入binlog，这个时刻记为T1；</li>
<li>之后传给备库B，备库接受完binlog的时刻记为T2；</li>
<li>备库B执行完这个事务记为T3。</li>
</ol>
<p>所谓主备延迟，就是同一个事务T3-T1。<br>在备库执行show slave status 命令，seconds_behind_master显示了当前备库延迟，精度秒。</p>
<p>延迟来源：</p>
<ol>
<li>为了省钱，备库机器较差。</li>
<li>备库常用来读，查询压力大。一般可以这样处理：一主多从，或者通过binlog输出到外部系统，比如Hadoop。</li>
<li>大事务，因为主库上必须等事务执行完成才会写入binlog。<br>PS. 关于第三点，我在实习的时候就吃过这个亏，说多了都是泪。还好不是重要的库。</li>
<li>大表DDL。</li>
<li>主备延迟的一个大方向原因，备库的并行复制能力。</li>
</ol>
<h3 id="可靠性优先策略"><a href="#可靠性优先策略" class="headerlink" title="可靠性优先策略"></a>可靠性优先策略</h3><p>优先考虑。<br>在上图双M结果下，从状态1到状态2切换的详细过程：</p>
<ol>
<li>判断备库B现在的seconds_behind_master，如果小于某个值（比如 5 秒）继续下一步，否则持续重试这一步；</li>
<li>把主库A改成只读状态，即把readonly 设置成true；</li>
<li>判断备库 B 的 seconds_behind_master的值，直到这个值变成 0 为止；</li>
<li>把备库 B 改成可读写状态，也就是把 readonly 设置为 false；</li>
<li>把业务请求切到备库 B。</li>
</ol>
<p>上述切换流程，一般由专门的HA系统完成，但会存在一段时间都不可用时间。</p>
<h3 id="可用性优先策略"><a href="#可用性优先策略" class="headerlink" title="可用性优先策略"></a>可用性优先策略</h3><p>如果强行把步骤4、5调整到最开始执行，这样就几乎不存在不可用时间，但会引起数据不一致。<br>数据不一致的例子，表结构如下（<strong>自增id</strong>）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">1</span>),(<span class="number">2</span>),(<span class="number">3</span>);</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>执行两条插入语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">5</span>);</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>假设，现在主库其他数据表有大量更新，主备延迟达到5秒。在插入一条c=4语句，发起主备切换。<br>下图，<strong>binlog_format=mixed时</strong><br><img src="https://img-blog.csdnimg.cn/20190126184905259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>步骤2，主库A执行完insert，插入一行（4,4），之后开始进行主备切换。</li>
<li>步骤3，由于5秒延迟，备库还没来得及应用“插入c=4”这个中转日志，就开始接受客户端“插入c=5”的命令。</li>
<li>步骤4，备库B插入一行（4,5），并把这个binlog发给主库A。</li>
<li>步骤5，备库B执行“插入c=4”，插入一行（5,4）。binlog传给A，插入（5,5）.</li>
</ol>
<p><strong>binlog_format=row时</strong><br><img src="https://img-blog.csdnimg.cn/20190126185605299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因为该格式会记录插入行的所有字段值，所以只会有一行不一致。两边的主备同步的应用线程会报错 duplicate key error 并停止。</p>
<h3 id="可靠性异常切换"><a href="#可靠性异常切换" class="headerlink" title="可靠性异常切换"></a>可靠性异常切换</h3><p>假设，主库A和备库B主备延迟30分钟，这时A掉电，HA系统要切换B作为主库。<br><img src="https://img-blog.csdnimg.cn/20190126190150658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这时必须等到备库B seconds_behind_master=0 之后，才能切换。</p>
<h2 id="26-备库为什么会延迟好几个小时？"><a href="#26-备库为什么会延迟好几个小时？" class="headerlink" title="26 | 备库为什么会延迟好几个小时？"></a>26 | 备库为什么会延迟好几个小时？</h2><p>主备复制的流程图在24 | MySQL是怎么保证主备一致的提过了。<br>备库通过sql_thread更新数据，5.6版本之前只支持单线程复制，所以主库并发高、TPS高会出现严重的主备延迟。<br><img src="https://img-blog.csdnimg.cn/20190217162322782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上图为改进的多线程复制模型，coordinator为原来的sql_thread，但不再直接更新数据，只负责中转日志和分发事务。worker数量由参数 slave_parallel_workers 决定（32核推荐配置8~16）。<br>coordinator分发需满足两个基本要求：</p>
<ol>
<li>不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个 worker 中。</li>
<li>同一个同一个事务不能被拆开，必须放到同一个worker 中。</li>
</ol>
<h3 id="并行复制策略"><a href="#并行复制策略" class="headerlink" title="并行复制策略"></a>并行复制策略</h3><ol>
<li>按库分发，hash库名到一个worker 中，MySQL 5.6 版本的并行复制策略。</li>
<li>按表分发，需将相同表hash到一个worker 中。</li>
<li>按行分发，按“库名 + 表名 + 唯一索引 a 的名字 +a 的值”hash到一个worker 中。</li>
</ol>
<p>MariaDB 利用了redo log 组提交 (group commit)特性，因为能在一组中提交，一定不会修改同一行。</p>
<p>MySQL 5.7 并行复制策略由参数 slave-parallel-type 来控制，配置成DATABASE使用5.6版本的策略，LOGICAL_CLOCK使用MariaDB 的策略，但进行了优化（针对两阶段提交）。</p>
<p>MySQL 5.7.22 新增了一个并行复制策略，基于 WRITESET 的并行复制。</p>
<p>ps：复制策略比较复杂，只是记录一下。</p>
<h2 id="27-主库出问题了，从库怎么办？"><a href="#27-主库出问题了，从库怎么办？" class="headerlink" title="27 | 主库出问题了，从库怎么办？"></a>27 | 主库出问题了，从库怎么办？</h2><p><img src="https://img-blog.csdnimg.cn/20190224144019294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>虚线箭头表示的是主备关系，也就是 A 和 A’互为主备， 从库 B、C、D 指向的是主库 A。<br>相比于一主一备，一主多从结构在切换完成后，A’会成为新的主库，从库 B、C、D 也要改接到 A’。</p>
<h3 id="基于位点的主备切换"><a href="#基于位点的主备切换" class="headerlink" title="基于位点的主备切换"></a>基于位点的主备切换</h3><p>当我们把节点 B 设置成节点 A’的从库的时候，需要执行一条change master 命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>主库A’的信息</span><br><span class="line">MASTER_HOST<span class="operator">=</span>$host_name </span><br><span class="line">MASTER_PORT<span class="operator">=</span>$port </span><br><span class="line">MASTER_USER<span class="operator">=</span>$user_name </span><br><span class="line">MASTER_PASSWORD<span class="operator">=</span>$password </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>同步位点</span><br><span class="line">MASTER_LOG_FILE<span class="operator">=</span>$master_log_name </span><br><span class="line">MASTER_LOG_POS<span class="operator">=</span>$master_log_pos  </span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p>最后两个参数表示要从主库的 master_log_name 文件的 master_log_name 文件的 master_log_pos 这个位置的日志继续同步。而这个位置就是我们所说的同步位点，也就是主库对应的文件名和日志偏移量。<br>同步位点很难取到精确位置，因为不能丢数据，需要需要找一个“稍微靠前”的位点，然后判断跳过已经执行过的事务。</p>
<ol>
<li>等待新主库 A’把中转日志（relay log）全部同步完成；</li>
<li>在 A’上执行 show master status 命令，得到当前 A’上最新的 File 和 Position；</li>
<li>取原主库 A 故障的时刻 T；</li>
<li>用 mysqlbinlog 工具解析 A’的 File，得到 T 时刻的位点。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog File <span class="comment">--stop-datetime=T --start-datetime=T</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/2019022414520599.png" alt="在这里插入图片描述"><br>假设在 T 这个时刻，主库 A 已经执行完成了一个 insert 语句插入了一行数据 R，并且已经将 binlog 传给了 A’和 B，然后在传完的瞬间主库 A 的主机就掉电了。这种情况下，再从这个位点同步时，会把已经存在在B的数据再次同步过来，出现主键冲突。</p>
<ol>
<li>主动跳过事务：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> sql_slave_skip_counter<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">start</span> slave;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<ol>
<li>跳过设置 slave_skip_errors 参数，直接设置跳过指定错误。“1032”删除找不到行，“1062”主键冲突。同步完成后，稳定一段时间，去掉该设置。</li>
</ol>
<h3 id="GTID"><a href="#GTID" class="headerlink" title="GTID"></a>GTID</h3><p>MySQL 5.6 版本引入了 GTID。<br>GTID启动加上参数 gtid_mode=on 和 enforce_gtid_consistency=on。<br>GTID 的全称是 Global Transaction Identifier，也就是全局事务 ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>server_uuid实例第一次启动时生成，全局唯一</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>gno一个整数，初始值是 <span class="number">1</span>，每次提交事务的时候分配给这个事务，并<span class="operator">+</span><span class="number">1</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>mysql文档中叫GTID<span class="operator">=</span>source_id:transaction_id</span><br><span class="line">GTID<span class="operator">=</span>server_uuid:gno</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>如果从库中已经存在了某事务，使用以下方式跳过。前三句执行了一个空事务，并把GTID加到了从库的集合中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> gtid_next<span class="operator">=</span><span class="string">&#x27;aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10&#x27;</span>;</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">set</span> gtid_next<span class="operator">=</span>automatic;</span><br><span class="line"><span class="keyword">start</span> slave;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h3 id="基于-GTID-的主备切换"><a href="#基于-GTID-的主备切换" class="headerlink" title="基于 GTID 的主备切换"></a>基于 GTID 的主备切换</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> </span><br><span class="line">MASTER_HOST<span class="operator">=</span>$host_name </span><br><span class="line">MASTER_PORT<span class="operator">=</span>$port </span><br><span class="line">MASTER_USER<span class="operator">=</span>$user_name </span><br><span class="line">MASTER_PASSWORD<span class="operator">=</span>$password </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>使用GTID协议</span><br><span class="line">master_auto_position<span class="operator">=</span><span class="number">1</span> </span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>从库会把自己的GTID集合传给切换的主库，主库会计算差集，然后把不同的同步给从库。</p>
<h2 id="28-读写分离有哪些坑？"><a href="#28-读写分离有哪些坑？" class="headerlink" title="28 | 读写分离有哪些坑？"></a>28 | 读写分离有哪些坑？</h2><p>上节的主从是由客户端直联的。<br>另一种架构proxy：<br><img src="https://img-blog.csdnimg.cn/20190224152550874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代理架构，客户端不会感知数据库端的细节，只需对接代理。但加一层代理，链路会变长，而且代理也需要高可用架构。<br>不管是哪种架构，主备都存在延迟。</p>
<h3 id="强制走主库方案"><a href="#强制走主库方案" class="headerlink" title="强制走主库方案"></a>强制走主库方案</h3><p>对于一些需要拿到实时结果的请求，分发到主库上。但对一些都需要实时结果的金融业务，就需要放弃读写分离。</p>
<h3 id="sleep方案"><a href="#sleep方案" class="headerlink" title="sleep方案"></a>sleep方案</h3><p>延迟几秒再去读从库，但超过这个时间的同步还是拿不到最新的数据。</p>
<h3 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a>判断主备无延迟方案</h3><ol>
<li>判断show slave status 结果里的 seconds_behind_master 参数的值是否等于0，但该值精度为秒。</li>
<li>对比位点确保主备无延迟，Master_Log_File 和 Relay_Master_Log_File、Read_Master_Log_Pos 和 Exec_Master_Log_Pos 这两组值完全相同，就表示接收到的日志已经同步完成。</li>
<li>对比 GTID 集合确保主备无延迟，Retrieved_Gtid_Set、Executed_Gtid_Set是否相同。、</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2019022415380793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上述方案，只会判断从库已经收到的事务，是否执行完，但对于一些主库已执行，但从库还没收到的情况，还是存在主备延迟。</p>
<h3 id="配合-semi-sync"><a href="#配合-semi-sync" class="headerlink" title="配合 semi-sync"></a>配合 semi-sync</h3><p>要解决这个问题，就要引入半同步复制，也就是semi-sync replication。</p>
<ol>
<li>事务提交的时候，主库把 binlog 发给从库；</li>
<li>从库收到 binlog 以后，发回给主库一个 ack，表示收收到；</li>
<li>主库收到这个 ack 以后，才能给客户端返回“事务完成”的确认。</li>
</ol>
<p>但一主多从的情况主库只要收到一个从库返回ack，就会提交事务。所以在查询其他从库时，可能还是会存在主备延迟。<br>其实，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位点或者 GTID 集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。</p>
<h3 id="等主库位点方案"><a href="#等主库位点方案" class="headerlink" title="等主库位点方案"></a>等主库位点方案</h3><p>实际上并不需要等待主备完全同步，其实从库查询trx1时只需要该事务完成就可以返回：<br><img src="https://img-blog.csdnimg.cn/2019022416443224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>首先看一条sql</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> master_pos_wait(file, pos[, timeout]);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol>
<li>它是在从库执行的；</li>
<li>参数 file 和 pos 指的是主库上的文件名和位置；</li>
<li>timeout 可选，设置为正整数 N 表示这个函数最多等待N 秒。</li>
</ol>
<p>这个会返回一个正整数 M，表示从命令开始执行，到应用完 file 和 pos 表示的 binlog 位置，执行了多少事务。除了正常返回之外，还会返回：</p>
<ol>
<li>如果执行期间，备库同步线程发生异常，则返回 NULL；</li>
<li>如果等待超过 N 秒，就返回 -1；</li>
<li>如果刚开始执行的时候，就发现已经执行过这个位置了，则返回 0。</li>
</ol>
<p>所以可以这么判断：</p>
<ol>
<li>trx1 事务更新完成后，马上执行 show master status 得到当前主库执行到的File 和 Position；</li>
<li>选定一个从库执行查询语句；</li>
<li>在从库上执行 select master_pos_wait(File, Position, 1)；</li>
<li>如果返回值是 &gt;=0 的正整数，则在这个从库执行查询语句；</li>
<li>否则，到主库执行查询语句。</li>
</ol>
<p>所以可能存在将流量打到主库的情况，所以需要做好主库限流策略。</p>
<h3 id="GTID-方案"><a href="#GTID-方案" class="headerlink" title="GTID 方案"></a>GTID 方案</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> wait_for_executed_gtid_set(gtid_set, <span class="number">1</span>);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol>
<li>等待，直到这个库执行的事务中包含传入的 gtid_set，返回 0；</li>
<li>超时返回 1。</li>
</ol>
<p>MySQL 5.7.6 版本开始，允许在执行完更新类事务后，把这个事务的 GTID 返回给客户端，这样等 GTID 的方案就可以减少一次查询。</p>
<ol>
<li>trx1 事务更新完成后，从返回包直接获取这个事务的 GTID，记为 gtid1；</li>
<li>选定一个从库执行查询语句；</li>
<li>在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；</li>
<li>如果返回值是 0，则在这个从库执行查询语句；</li>
<li>否则，到主库执行查询语句。</li>
</ol>
<h2 id="29-如何判断一个数据库是不是出问题了？"><a href="#29-如何判断一个数据库是不是出问题了？" class="headerlink" title="29 | 如何判断一个数据库是不是出问题了？"></a>29 | 如何判断一个数据库是不是出问题了？</h2><h3 id="select-1-判断"><a href="#select-1-判断" class="headerlink" title="select 1 判断"></a>select 1 判断</h3><p>当前并发查询数超过innodb_thread_concurrency时， select 1会返回，但执行查询命令时会等待。<br>该参数默认值是0，表示不限制并发查询数，建议把 innodb_thread_concurrency 设置为 64~128 之间的值。<strong>不是并发连接数。</strong></p>
<h3 id="查表判断"><a href="#查表判断" class="headerlink" title="查表判断"></a>查表判断</h3><p>在系统库（mysql 库）里创建一个表，比如命名为 health_check，里面只放一行数据，然后定期执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.health_check; </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>但有其他一个问题，更新事务要写 binlog，binlog 所在磁盘的空间占用率达到 100%，那么所有的更新语句和事务提交的 commit 语句就都会被堵住。但是，系统这时候还是可以正常读数据的。</p>
<h3 id="更新判断"><a href="#更新判断" class="headerlink" title="更新判断"></a>更新判断</h3><p>常见做法是放一个 timestamp 字段，用来表示最后一次执行检测的时间。但备库不能写同一行，所以需要使用多行，id为server_id。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> update mysql.health_check <span class="keyword">set</span> t_modified<span class="operator">=</span>now();</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>但有可能，机器的I/O已经100%，但刚好健康检查的sql拿到了资源，成功返回了。</p>
<h3 id="内部统计"><a href="#内部统计" class="headerlink" title="内部统计"></a>内部统计</h3><p>关于磁盘利用率100%的问题。<br>MySQL 5.6 版本以后提供的 performance_schema 库，就在 file_summary_by_event_name 表里统计了每次 IO 请求的时间。</p>
<p>老师比较倾向的方案，是优先考虑 update 系统表，，然后再配合增加检测 performance_schema的信息。</p>
<h2 id="30-答疑文章（二）：用动态的观点看加锁"><a href="#30-答疑文章（二）：用动态的观点看加锁" class="headerlink" title="30 | 答疑文章（二）：用动态的观点看加锁"></a>30 | 答疑文章（二）：用动态的观点看加锁</h2><p>先复习一下老师在 21 | 为什么我只改一行的语句，锁这么多？ 文章中提到了两个“原则”、两个“优化”和一个“bug”。<br>该文章基于下面的表结构：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<h3 id="不等号条件里的等值查询"><a href="#不等号条件里的等值查询" class="headerlink" title="不等号条件里的等值查询"></a>不等号条件里的等值查询</h3><p>等值查询和“遍历”有什么区别？为什么我们文章的例子里面，where 条件是不等号，这个过程里也有等值查询？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">9</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">12</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> <span class="keyword">for</span> update;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>上面的规则可以知道加锁区间(0,5]、(5,10] 和 (10, 15)。</p>
<ol>
<li>首先这个查询语句的语义是 order by id desc，要拿到满足条件的所有行，优化器必须先找到“第一个 id&lt;12 的值”。</li>
<li>这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找id=12 的这个值，只是最终没找到，但找到了(10,15) 这个间隙。</li>
<li>然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到 id=5 这一行，所以会加一个 next-key lock (0,5]。</li>
</ol>
<p>也就是说，在执行过程中，通过树搜索的方式定位记录的时候，用的是“等值查询”的方法。</p>
<h3 id="等值查询的过程"><a href="#等值查询的过程" class="headerlink" title="等值查询的过程"></a>等值查询的过程</h3><p>下面这个语句的加锁范围是什么？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="keyword">in</span>(<span class="number">5</span>,<span class="number">20</span>,<span class="number">10</span>) lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190224175055777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>in 语句使用了索引 c 并且 rows=3，说明这三个值都是通过 B+ 树搜索定位的。<br>在查找 c=5 的时候，先锁住了 (0,5]。但是因为 c 不是唯一索引，为了确认还有没有别的记录 c=5，就要向右遍历，找到 c=10 才确认没有了，这个过程满足优化 2，所以加了间隙锁 (5,10)。<br>同样的，执行 c=10 这个逻辑的时候，加锁的范围是(5,10] 和 (10,15)；执行 c=20 这个逻辑的时候，加锁的范围是 (15,20] 和 (20,25)。<br>这条语句在索引 c 上加的三个记录锁的顺序是：先加 c=5 的记录锁，再加 c=10 的记录锁，最后加 c=20 的记录锁。</p>
<h3 id="怎么看死锁？"><a href="#怎么看死锁？" class="headerlink" title="怎么看死锁？"></a>怎么看死锁？</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="keyword">in</span>(<span class="number">5</span>,<span class="number">20</span>,<span class="number">10</span>) <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> <span class="keyword">for</span> update;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>当执行上述命令时，加锁顺序和会之前那句相反，会产生死锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engine innodb status;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190224180622724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>三部分：</p>
<ol>
<li>TRANSACTION，是第一个事务的信息；</li>
<li>TRANSACTION，是第二个事务的信息；</li>
<li>WE ROLL BACK TRANSACTION (1)，最终回滚了第一个事务。</li>
</ol>
<p>得到的结论：</p>
<ol>
<li>由于锁是一个个加的，要避免死锁，对同一组资源，要按照尽量相同的顺序访问；</li>
<li>在发生死锁的时刻，for update 这条语句占有的资源更多，回滚成本更大，所以 InnoDB 选择了回滚成本更小的 lockin share mode 语句，来回滚。</li>
</ol>
<h3 id="怎么看锁等待？"><a href="#怎么看锁等待？" class="headerlink" title="怎么看锁等待？"></a>怎么看锁等待？</h3><p><img src="https://img-blog.csdnimg.cn/20190224181715899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>session A 并没有锁住 c=10 这个记录，delete之后不能insert。<br><img src="https://img-blog.csdnimg.cn/20190224181747208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于 delete 操作把 id=10 这一行删掉了，原来的两个间隙 (5,10)、(10,15）变成了一个 (5,15)。</p>
<h3 id="update-的例子"><a href="#update-的例子" class="headerlink" title="update 的例子"></a>update 的例子</h3><p><img src="https://img-blog.csdnimg.cn/20190224182017655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>虽然session A 的加锁范围是索引 c 上的 (5,10]、(10,15]、(15,20]、(20,25] 和 (25,supremum]，但update后加锁范围变成了下图：<br><img src="https://img-blog.csdnimg.cn/20190224182324907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MySQL45%E8%AE%B2/" rel="tag"># MySQL45讲</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/mysql/mysql45-1/" rel="prev" title="「MySQL45讲」1-15讲">
      <i class="fa fa-chevron-left"></i> 「MySQL45讲」1-15讲
    </a></div>
      <div class="post-nav-item">
    <a href="/mysql/mysql45-3/" rel="next" title="「MySQL45讲」31-45讲">
      「MySQL45讲」31-45讲 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E2%80%9Corder-by%E2%80%9D%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="nav-text">16 | “order by”是怎么工作的？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F"><span class="nav-text">全字段排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rowid-%E6%8E%92%E5%BA%8F"><span class="nav-text">rowid 排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F-VS-rowid-%E6%8E%92%E5%BA%8F"><span class="nav-text">全字段排序 VS rowid 排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-text">小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%A6%E5%A4%96"><span class="nav-text">另外</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E6%98%BE%E7%A4%BA%E9%9A%8F%E6%9C%BA%E6%B6%88%E6%81%AF%EF%BC%9F"><span class="nav-text">17 | 如何正确地显示随机消息？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%B8%B4%E6%97%B6%E8%A1%A8"><span class="nav-text">内存临时表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E4%B8%B4%E6%97%B6%E8%A1%A8"><span class="nav-text">磁盘临时表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95"><span class="nav-text">随机排序方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%BA%9BSQL%E8%AF%AD%E5%8F%A5%E9%80%BB%E8%BE%91%E7%9B%B8%E5%90%8C%EF%BC%8C%E6%80%A7%E8%83%BD%E5%8D%B4%E5%B7%AE%E5%BC%82%E5%B7%A8%E5%A4%A7%EF%BC%9F"><span class="nav-text">18 | 为什么这些SQL语句逻辑相同，性能却差异巨大？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E6%9D%A1%E4%BB%B6%E5%AD%97%E6%AE%B5%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C"><span class="nav-text">案例一：条件字段函数操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">案例二：隐式类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%89%EF%BC%9A%E9%9A%90%E5%BC%8F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2"><span class="nav-text">案例三：隐式字符编码转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%9F%A5%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%EF%BC%8C%E4%B9%9F%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B9%88%E6%85%A2%EF%BC%9F"><span class="nav-text">19 | 为什么我只查一行的语句，也执行这么慢？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%B1%BB%EF%BC%9A%E6%9F%A5%E8%AF%A2%E9%95%BF%E6%97%B6%E9%97%B4%E4%B8%8D%E8%BF%94%E5%9B%9E"><span class="nav-text">第一类：查询长时间不返回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%B1%BB%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%85%A2"><span class="nav-text">第二类：查询慢</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">20 | 幻读是什么，幻读有什么问题？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">幻读是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%B4%E9%9A%99%E9%94%81%E5%92%8Cnext-key-lock"><span class="nav-text">间隙锁和next-key lock</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%94%B9%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%EF%BC%8C%E9%94%81%E8%BF%99%E4%B9%88%E5%A4%9A%EF%BC%9F"><span class="nav-text">21 | 为什么我只改一行的语句，锁这么多？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E2%80%9C%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%E2%80%9D%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-text">22 | MySQL有哪些“饮鸩止渴”提高性能的方法？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%AD%E8%BF%9E%E6%8E%A5%E9%A3%8E%E6%9A%B4"><span class="nav-text">短连接风暴</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-text">慢查询性能问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E7%9A%84%EF%BC%9F"><span class="nav-text">23 | MySQL是怎么保证数据不丢的？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#binlog%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="nav-text">binlog写入机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redo-log%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="nav-text">redo log写入机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E7%9A%84%EF%BC%9F"><span class="nav-text">24 | MySQL是怎么保证主备一致的？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-%E4%B8%BB%E5%A4%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-text">MySQL 主备的基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binlog-%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A0%BC%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="nav-text">binlog 的三种格式对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%A4%8D%E5%88%B6%E9%97%AE%E9%A2%98"><span class="nav-text">循环复制问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="nav-text">25 | MySQL是怎么保证高可用的？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%A4%87%E5%BB%B6%E8%BF%9F"><span class="nav-text">主备延迟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%98%E5%85%88%E7%AD%96%E7%95%A5"><span class="nav-text">可靠性优先策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E7%94%A8%E6%80%A7%E4%BC%98%E5%85%88%E7%AD%96%E7%95%A5"><span class="nav-text">可用性优先策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%BC%82%E5%B8%B8%E5%88%87%E6%8D%A2"><span class="nav-text">可靠性异常切换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-%E5%A4%87%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BB%B6%E8%BF%9F%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%97%B6%EF%BC%9F"><span class="nav-text">26 | 备库为什么会延迟好几个小时？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%AD%96%E7%95%A5"><span class="nav-text">并行复制策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-%E4%B8%BB%E5%BA%93%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86%EF%BC%8C%E4%BB%8E%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-text">27 | 主库出问题了，从库怎么办？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E4%BD%8D%E7%82%B9%E7%9A%84%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2"><span class="nav-text">基于位点的主备切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GTID"><span class="nav-text">GTID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-GTID-%E7%9A%84%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2"><span class="nav-text">基于 GTID 的主备切换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91%EF%BC%9F"><span class="nav-text">28 | 读写分离有哪些坑？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E8%B5%B0%E4%B8%BB%E5%BA%93%E6%96%B9%E6%A1%88"><span class="nav-text">强制走主库方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep%E6%96%B9%E6%A1%88"><span class="nav-text">sleep方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%B8%BB%E5%A4%87%E6%97%A0%E5%BB%B6%E8%BF%9F%E6%96%B9%E6%A1%88"><span class="nav-text">判断主备无延迟方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E5%90%88-semi-sync"><span class="nav-text">配合 semi-sync</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E4%B8%BB%E5%BA%93%E4%BD%8D%E7%82%B9%E6%96%B9%E6%A1%88"><span class="nav-text">等主库位点方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GTID-%E6%96%B9%E6%A1%88"><span class="nav-text">GTID 方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E4%B8%8D%E6%98%AF%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86%EF%BC%9F"><span class="nav-text">29 | 如何判断一个数据库是不是出问题了？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select-1-%E5%88%A4%E6%96%AD"><span class="nav-text">select 1 判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%A1%A8%E5%88%A4%E6%96%AD"><span class="nav-text">查表判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E5%88%A4%E6%96%AD"><span class="nav-text">更新判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%BB%9F%E8%AE%A1"><span class="nav-text">内部统计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%94%A8%E5%8A%A8%E6%80%81%E7%9A%84%E8%A7%82%E7%82%B9%E7%9C%8B%E5%8A%A0%E9%94%81"><span class="nav-text">30 | 答疑文章（二）：用动态的观点看加锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E7%AD%89%E5%8F%B7%E6%9D%A1%E4%BB%B6%E9%87%8C%E7%9A%84%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2"><span class="nav-text">不等号条件里的等值查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">等值查询的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%9C%8B%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-text">怎么看死锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%9C%8B%E9%94%81%E7%AD%89%E5%BE%85%EF%BC%9F"><span class="nav-text">怎么看锁等待？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#update-%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-text">update 的例子</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Senkorl</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>
    
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
