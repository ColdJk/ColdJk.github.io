<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Comic Sans MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"senkorl.xyz","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="31 | 误删数据后除了跑路，还能怎么办？千万不能误删 误删行binlog_format&#x3D;row 和 binlog_row_image&#x3D;FULL 可以使用Flashback回放。不建议直接在主库使用，应该在备库执行，然后再将确认过的临时库的数据，恢复回主库。 误删库 &#x2F; 表取全量备份，和全量备份时间点之后的binlog恢复。但mysqlbinlog不够快。一个加速的方法，将全量备份恢复的临时实">
<meta property="og:type" content="article">
<meta property="og:title" content="「MySQL45讲」31-45讲">
<meta property="og:url" content="https://senkorl.xyz/mysql/mysql45-3/index.html">
<meta property="og:site_name" content="Senkorl">
<meta property="og:description" content="31 | 误删数据后除了跑路，还能怎么办？千万不能误删 误删行binlog_format&#x3D;row 和 binlog_row_image&#x3D;FULL 可以使用Flashback回放。不建议直接在主库使用，应该在备库执行，然后再将确认过的临时库的数据，恢复回主库。 误删库 &#x2F; 表取全量备份，和全量备份时间点之后的binlog恢复。但mysqlbinlog不够快。一个加速的方法，将全量备份恢复的临时实">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190303140052451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190303142012727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190303160443116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190303162559764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190303164408578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190303165312222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190323141100903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190323141656910.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190323142859657.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190323150235371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190323150623954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190323155045583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190330160223927.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190330161615294.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190330161650414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190330161906556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019033016274258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190330162941977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190414131150949.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190414142847821.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190414143032307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190414143059107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190414144030343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190414145110368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190414145508626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190414145756364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190414150329261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190414152036281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190414160309689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2020-03-15T04:02:05.000Z">
<meta property="article:modified_time" content="2020-03-15T04:02:05.000Z">
<meta property="article:author" content="Senkorl">
<meta property="article:tag" content="MySQL45讲">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190303140052451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70">

<link rel="canonical" href="https://senkorl.xyz/mysql/mysql45-3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>「MySQL45讲」31-45讲 | Senkorl</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Senkorl</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">专注于最有价值的事情.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/myhome/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://senkorl.xyz/mysql/mysql45-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Senkorl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Senkorl">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          「MySQL45讲」31-45讲
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-15 12:02:05" itemprop="dateCreated datePublished" datetime="2020-03-15T12:02:05+08:00">2020-03-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <meta name="referrer" content="no-referrer">

<h2 id="31-误删数据后除了跑路，还能怎么办？"><a href="#31-误删数据后除了跑路，还能怎么办？" class="headerlink" title="31 | 误删数据后除了跑路，还能怎么办？"></a>31 | 误删数据后除了跑路，还能怎么办？</h2><p><strong>千万不能误删</strong></p>
<h3 id="误删行"><a href="#误删行" class="headerlink" title="误删行"></a>误删行</h3><p>binlog_format=row 和 binlog_row_image=FULL 可以使用Flashback回放。<br>不建议直接在主库使用，应该在备库执行，然后再将确认过的临时库的数据，恢复回主库。</p>
<h3 id="误删库-表"><a href="#误删库-表" class="headerlink" title="误删库 / 表"></a>误删库 / 表</h3><p>取全量备份，和全量备份时间点之后的binlog恢复。但mysqlbinlog不够快。<br>一个加速的方法，将全量备份恢复的临时实例，设置为线上备库的从库。</p>
<h3 id="延迟复制备库"><a href="#延迟复制备库" class="headerlink" title="延迟复制备库"></a>延迟复制备库</h3><p>MySQL 5.6 版本引入，通过 CHANGE MASTER TO MASTER_DELAY = N 命令，可以指定这个备库持续保持跟主库有N 秒的延迟。</p>
<h2 id="32-为什么还有kill不掉的语句？"><a href="#32-为什么还有kill不掉的语句？" class="headerlink" title="32 | 为什么还有kill不掉的语句？"></a>32 | 为什么还有kill不掉的语句？</h2><p>kill query + 线程 id：表示终止这个线程中正在执行的语句；<br>kill connection + 线程 id，这里 connection 可缺省，表示断开这个线程的连接，如果这个线程有语句正在执行，也是要先停止正在执行的语句的。</p>
<p>mysql kill命令不是直接终止线程。</p>
<ol>
<li>把 session 的运行状态改成 THD::KILL_QUERY(将变量 killed 赋值为 THD::KILL_QUERY)；</li>
<li>给 session 的执行线程发一个信号。有些session 由于锁在等待，信号让session 退出等待来处理THD::KILL_QUERY 状态。</li>
</ol>
<p>mysql处理过程中有许多埋点，这些“埋点”的地方判断线程状态，如果发现线程状态是 THD::KILL_QUERY，才开始进入语句终止逻辑。</p>
<p>如果碰到一个被 killed 的事务一直处于回滚状态，尽量不要重启，因为重启之后该做的回滚动作还是不能少的，所以从恢复速度的角度来说，应该让它自己结束。如果这个语句可能会占用别的锁，或者由于占用 IO 资源过多，从而影响到了别的语句执行的话，就需要先做主备切换，切到新主库提供服务。<strong>避免大事务</strong></p>
<h2 id="33-我查这么多数据，会不会把数据库内存打爆？"><a href="#33-我查这么多数据，会不会把数据库内存打爆？" class="headerlink" title="33 | 我查这么多数据，会不会把数据库内存打爆？"></a>33 | 我查这么多数据，会不会把数据库内存打爆？</h2><h3 id="全表扫描对-server-层的影响"><a href="#全表扫描对-server-层的影响" class="headerlink" title="全表扫描对 server 层的影响"></a>全表扫描对 server 层的影响</h3><p><img src="https://img-blog.csdnimg.cn/20190303140052451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>net_buffer由参数 net_buffer_length 定义的，默认是 16k。<br>mysql是遍读遍发的，所以当net_buffer写满的时候就需要等待。使用show processlist可以看到state=“Sending to client”。<br>mysql还要一个state=“Sending data”，它的意思只是“正在执行”。</p>
<h3 id="全表扫描对-InnoDB-的影响"><a href="#全表扫描对-InnoDB-的影响" class="headerlink" title="全表扫描对 InnoDB 的影响"></a>全表扫描对 InnoDB 的影响</h3><p>介绍 WAL 机制时，分析了Buffer Pool 加速更新的作用。Buffer Pool 还有一个更重要的作用，就是加速查询。<br>执行 show engine innodb status可以查看一个系统当前的 BP 命中率。<br>InnoDB Buffer Pool 的大小是由参数 innodb_buffer_pool_size 确定的，一般建议设置成可用物理内存的 60%~80%。</p>
<p>InnoDB 内存管理用的是最近最少使用 (LRU) 算法，这个算法的核心就是淘汰最久未使用的数据。<br>如果在查询历史数据使用这个算法，会导致很多请求会从磁盘读取数据。所以mysql对LRU算法进行了改进。<br><img src="https://img-blog.csdnimg.cn/20190303142012727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在 InnoDB 实现上，按照 5:3 的比例把整个 LRU 链表分成了 young 区域和 old 区域。</p>
<ol>
<li>访问数据页P3，在young区所以把它移到链表同步。</li>
<li>如果访问不存在的数据，则把链表尾部数据淘汰，但把新数据页Px放在LRU_old处。</li>
<li>处于 old 区域的数据页，每次被访问的时候都要做下面这个判断：<br>若这个数据页在 LRU 链表中存在的时间超过了 1 秒，就把它移动到链表头部；<br>如果这个数据页在 LRU 链表中存在的时间短于 1 秒，位置保持不变。</li>
</ol>
<p>1s由参数 innodb_old_blocks_time 控制的。其默认值是 1000，单位毫秒。</p>
<h2 id="34-到底可不可以使用join？"><a href="#34-到底可不可以使用join？" class="headerlink" title="34 | 到底可不可以使用join？"></a>34 | 到底可不可以使用join？</h2><p>表结构</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t2` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `a` (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> idata;</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">1000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 <span class="keyword">like</span> t2;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">100</span>)</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure>

<h3 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a>Index Nested-Loop Join</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.a<span class="operator">=</span>t2.a);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>t1 是驱动表，t2 是被驱动表。<br><img src="https://img-blog.csdnimg.cn/20190303160443116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>从表 t1 中读入一行数据 R；</li>
<li>从数据行 R 中，取出 a 字段到表 t2 里去查找；</li>
<li>取出表 t2 中满足条件的行，跟 R 组成一行，作为结果集的一部分；</li>
<li>重复执行步骤 1 到 3，直到表 t1 的末尾循环结束。</li>
</ol>
<p>t1只有100行，所有一共扫描200行。<br>如果执行select * from t1，再执行select * from t2 where a=$R.a。虽然都可以走索引，也只扫描200行。但需要执行101行sql。<br>如果可以走索引：</p>
<ol>
<li>使用 join 语句，性能比强行拆成多个单表执行 SQL 语句的性能要好；</li>
<li>如果使用 join 语句的话，需要让小表做驱动表。</li>
</ol>
<h3 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested-Loop Join"></a>Simple Nested-Loop Join</h3><p>如果驱动表用不上索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.a<span class="operator">=</span>t2.b);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>因为t2.b没有索引，所以需要全表扫描。总共需扫描100*1000行。</p>
<p>MySQL 没有使用 Simple Nested-Loop Join 算法，而是使用了“Block Nested-Loop Join”算法，简称BNL。</p>
<h3 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a>Block Nested-Loop Join</h3><p><img src="https://img-blog.csdnimg.cn/20190303162559764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>把表 t1 的数据读入线程内存 join_buffer 中，由于我们这个语句中写的是 select *，因此是把整个表 t1 放入了内存；</li>
<li>扫描表 t2，把表 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回。</li>
</ol>
<p>虽然都会扫描100*1000行，但BNL是内存判断，所以会快一点。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>如果可以使用被驱动表的索引，join 语句还是有其优势的；</li>
<li>不能使用被驱动表的索引，只能使用 BNL 算法，这样的语句就尽量不要使用；</li>
<li>在使用 join 的时候，应该让小表做驱动表。</li>
</ol>
<p>如果被驱动表是个大表，会把冷数据的page加入到buffer pool，并且BNL要扫描多次，两次扫描的时间可能会超过1秒，使上节提到的分代LRU优化失效，把热点数据从buffer pool中淘汰掉，影响正常业务的查询效率。</p>
<h2 id="35-join语句怎么优化？"><a href="#35-join语句怎么优化？" class="headerlink" title="35 | join语句怎么优化？"></a>35 | join语句怎么优化？</h2><p>表结构</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index(a));</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t1;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> idata;</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">1000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(i, <span class="number">1001</span><span class="operator">-</span>i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">1000000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>

<h3 id="Multi-Range-Read-优化"><a href="#Multi-Range-Read-优化" class="headerlink" title="Multi-Range Read 优化"></a>Multi-Range Read 优化</h3><p>回忆一下回表。回表是指，InnoDB 在普通索引 a 上查到主键 id 的值后，再根据一个个主键 id 的值到主键 id 的值到主键索引上去查整行数据的过程。<br>主键索引是一棵 B+ 树，在这棵树上，每次只能根据一个主键 id 查到一行数据。因此，回表肯定是一行行搜索主键索引的。<br><img src="https://img-blog.csdnimg.cn/20190303164408578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果随着 a 的值递增顺序查询的话，id 的值就变成随机的，那么就会出现随机访问，性能相对较差。虽然“按行查”这个机制不能改，但是调整查询的顺序，还是能够加速的。<br>因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。<br>MRR 优化的设计思路：</p>
<ol>
<li>根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中 ;</li>
<li>将 read_rnd_buffer 中的 id 进行递增排序；</li>
<li>排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回。</li>
</ol>
<p>read_rnd_buffer 的大小是由 read_rnd_buffer_size 参数控制。如果想要稳定地使用 MRR 优化的话，需要设置set optimizer_switch=“mrr_cost_based=off”，如果不设置，优化器会判断消耗，倾向于不使用MRR。</p>
<h3 id="Batched-Key-Access"><a href="#Batched-Key-Access" class="headerlink" title="Batched Key Access"></a>Batched Key Access</h3><p>MySQL 在 5.6 版本后开始引入的 Batched Key Acess(BKA) 算法了。其实就是对 NLJ 算法的优化。<br>NLJ 算法执行的逻辑是：从驱动表 t1，一行行地取出 a 的值，再到被驱动表 t2 去做 join。也就是说，对于表 t2 来说，每次都是匹配一个值。这时，MRR 的优势就用不上了。<br>BKA 算法就是缓存多行传给其他表，流程如下：<br><img src="https://img-blog.csdnimg.cn/20190303165312222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>启动BKA：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> optimizer_switch<span class="operator">=</span><span class="string">&#x27;mrr=on,mrr_cost_based=off,batched_key_access=on&#x27;</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="BNL-算法的性能问题"><a href="#BNL-算法的性能问题" class="headerlink" title="BNL 算法的性能问题"></a>BNL 算法的性能问题</h3><p>上篇文章末尾说了，如果一个使用 BNL 算法的 join 语句，多次扫描一个冷表，而且这个语句执行时间超过 1 秒，就会在再次扫描冷表的时候，把冷表的数据页移到LRU 链表头部。<br>为了减少这种影响，可以考虑增大join_buffer_size 的值，减少对被驱动表的扫描次数。</p>
<p>优化的常见做法是，给被驱动表的 join 字段加上索引，把 BNL 算法转成 BKA 算法。<br>还可以考虑使用临时表。使用临时表的大致思路是：</p>
<ol>
<li>把表 t2 中满足条件的数据放在临时表 tmp_t 中；</li>
<li>为了让 join 使用 BKA 算法，给临时表 tmp_t 的字段 b 加上索引；</li>
<li>让表 t1 和 tmp_t 做 join 操作。</li>
</ol>
<p>sql如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index(b))engine<span class="operator">=</span>innodb;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">&lt;=</span><span class="number">2000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> temp_t <span class="keyword">on</span> (t1.b<span class="operator">=</span>temp_t.b);</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<h3 id="扩展-hash-join"><a href="#扩展-hash-join" class="headerlink" title="扩展 -hash join"></a>扩展 -hash join</h3><p>mysql目前还没有hash索引，MariaDB支持。<br>所以可以自己实现在业务端。实现流程大致如下：</p>
<ol>
<li>select * from t1;取得表 t1 的全部 1000 行数据，在业务端存入一个 hash 结构；</li>
<li>select * from t2 where b&gt;=1 and b&lt;=2000; 获取表 t2 中满足条件的 2000 行数据。</li>
<li>把这 2000 行数据，一行一行地取到业务端，到 hash 结构的数据表中寻找匹配的数据。满足匹配的条件的这行数据，就作为结果集的一行。</li>
</ol>
<p>这个过程会比临时表方案的执行速度还要快一些。</p>
<h2 id="36-为什么临时表可以重名？"><a href="#36-为什么临时表可以重名？" class="headerlink" title="36 | 为什么临时表可以重名？"></a>36 | 为什么临时表可以重名？</h2><p>上节提到了临时表。<br>如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。当然，临时表也可以使用 Memory 引擎。<br>临时表的特点：</p>
<ol>
<li>临时表只能被创建它的 session 访问，对其他线程不可见。所以在这个 session 结束的时候，会自动删除临时表。</li>
<li>临时表可以与普通表同名（还是不要这么做）。</li>
<li>session A 内有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的是临时表。</li>
<li>show tables 命令不显示临时表。</li>
</ol>
<h3 id="临时表的应用"><a href="#临时表的应用" class="headerlink" title="临时表的应用"></a>临时表的应用</h3><p>分表分库跨库查询<br>分库分表系统都有一个中间层 proxy，如果 sql 能够直接确定某个分表，这种情况是最理想的。<br>但如果涉及到跨库，一般有两种方式</p>
<ol>
<li>在 proxy 层的进程代码中实现排序，但对 proxy 的功能和性能要求较高。</li>
<li>把各个分库拿到的数据，汇总到一个 MySQL 实例的一个表中，然后在这个汇总实例上做逻辑操作。如果每个分库的计算量都不饱和，那么直接可以在把临时表放到某个分库上。</li>
</ol>
<h3 id="为什么临时表可以重名？"><a href="#为什么临时表可以重名？" class="headerlink" title="为什么临时表可以重名？"></a>为什么临时表可以重名？</h3><p>MySQL 要给临时 InnoDB 表创建一个 frm 文件保存表结构定义，还要有地方保存表数据。<br>这个 frm 文件放在临时文件目录下，文件名的后缀是.frm，前缀是“#sql{进程 id}<em>{线程 id}</em> 序列号”。可以使用 select @@tmpdir 命令，来显示实例的临时文件目录。<br>表中数据存放：</p>
<ol>
<li>MySQL5.6 会在临时文件目录下创建一个相同前缀、以.ibd 为后缀的文件，用来存放数据文件；</li>
<li>MySQL5.7版本开始引入了一个临时文件表空间，专门用来存放临时文件的数据。因此，我们就不需要再创建 ibd 文件了。</li>
</ol>
<p>MySQL 维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个table_def_key。</p>
<ol>
<li>一个普通表的 table_def_key 的值是由“库名+ 表名”得到。</li>
<li>临时表，table_def_key 在“库名 + 表名”基础上，又加入了“server_id+thread_id”。</li>
</ol>
<h3 id="临时表和主备复制"><a href="#临时表和主备复制" class="headerlink" title="临时表和主备复制"></a>临时表和主备复制</h3><p>如果当前的 binlog_format=row，那么跟临时表有关的语句，就不会记录到 binlog 里。<br>binlog_format=statment/mixed 的时候，binlog 中才会记录临时表的操作。<br>这种情况下，创建临时表的语句会传到备库执行，因此备库的同步线程就会创建这个临时表。主库在线程退出的时候，会自动删除临时表，但是备库同步线程是持续在运行的。所以，这时候我们就需要在主库上再写一个 DROP TEMPORARY TABLE 传给执行。</p>
<h2 id="37-什么时候会使用内部临时表？"><a href="#37-什么时候会使用内部临时表？" class="headerlink" title="37 | 什么时候会使用内部临时表？"></a>37 | 什么时候会使用内部临时表？</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index(a));</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">1000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<p>执行这条语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> <span class="number">1000</span> <span class="keyword">as</span> f) <span class="keyword">union</span> (<span class="keyword">select</span> id <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> limit <span class="number">2</span>);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190323141100903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>第二行key=PRIMARY，说明第二个子句用到了索引 id</li>
<li>第三行 Extra 字段，说明 UNION 时使用了临时表 (Using temporary)</li>
</ul>
<p>执行流程：</p>
<ol>
<li>创建一个内存临时表，这个临时表只有一个整型字段 f，并且 f 是主键字段。</li>
<li>执行第一个子查询，得到 1000 这个值，并存入临时表中。</li>
<li>执行第二个子查询：拿到第一个1000，但已存在存入失败，拿到第二个999，存入成功。</li>
<li>从临时表中按行取出数据（1000和999两行），返回结果，并删除临时表。</li>
</ol>
<p>如果把上面这个语句中的 union 改成 union all的话，就不需要“去重”。这样执行的时候，就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端。因此也就不需要临时表了。</p>
<h3 id="group-by-执行流程"><a href="#group-by-执行流程" class="headerlink" title="group by 执行流程"></a>group by 执行流程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id<span class="operator">%</span><span class="number">10</span> <span class="keyword">as</span> m, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190323141656910.png" alt="在这里插入图片描述"></p>
<ol>
<li>Using index，表示这个语句使用了覆盖索引，选择了索引 a，不需要回表；</li>
<li>Using temporary，表示使用了临时表；</li>
<li>Using filesort，表示需要排序。</li>
</ol>
<p>执行流程：</p>
<ol>
<li>创建内存临时表，表里有两个字段 m 和 c，主键是 m；</li>
<li>扫描表 t1 的索引 a，依次取出叶子节点上的 id 值，计算 id%10 的结果，记为 x；如果临时表中没有主键为 x 的行，就插入一个记录 (x,1)，如果表中有主键为 x 的行，就将 x 这一行的 c 值加 1；</li>
<li>遍历完成后，再根据字段 m 做排序（内存临时表的排序 17 篇文章有），得到结果集返回给客户端。</li>
</ol>
<p>如果不需要排序则直接取内存临时表的数据。</p>
<p>但内存临时表的大小是有限制的，参数 tmp_table_size 就是控制这个内存大小的，默认是 16M。如果内存不够则使用磁盘临时表。</p>
<h3 id="group-by-优化方法"><a href="#group-by-优化方法" class="headerlink" title="group by 优化方法"></a>group by 优化方法</h3><p><strong>索引</strong><br>假设有个这样的数据结构：<br><img src="https://img-blog.csdnimg.cn/20190323142859657.png" alt="在这里插入图片描述"><br>如果可以确保输入的数据是有序的，那么计算 group by 的时候，就只需要从左到右，顺序扫描，依次累加。</p>
<ol>
<li>当碰到第一个 1 的时候，已经知道累积了 X 个 0，结果集里的第一行就是 (0,X);</li>
<li>当碰到第一个 2 的时候，已经知道累积了 Y 个 1，结果集里的第二行就是 (1,Y);</li>
</ol>
<p>InnoDB 的索引，就可以满足这个输入有序的条件。<br><strong>直接排序</strong><br>如果临时表数据量特别大，可让 MySQL 直接走磁盘临时表，在 group by 语句中加入 SQL_BIG_RESULT 这个提示（hint）。<br>MySQL 的优化器会直接用数组来存，而不是B+ 树存储。这样</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SQL_BIG_RESULT id<span class="operator">%</span><span class="number">100</span> <span class="keyword">as</span> m, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>执行流程：</p>
<ol>
<li>初始化 sort_buffer，确定放入一个整型字段，记为 m；</li>
<li>扫描表 t1 的索引 a，依次取出里面的 id 值, 将 id%100 的值存入 sort_buffer 中；</li>
<li>扫描完成后，对 sort_buffer 的字段 m 做排序（如果 sort_buffer 内存不够用，，就会利用磁盘临时文件辅助排序）；</li>
<li>排序完成后，就得到了一个有序数组。</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>MySQL 什么时候会使用内部临时表？</p>
<ol>
<li>如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；</li>
<li>join_buffer 是无序数组，sort_buffer 是有序数组，临时表是二维表结构；</li>
<li>如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如，union 需要用到唯一索引约束， group by 还需要用到另外一个字段来存累积计数。</li>
</ol>
<p>group by使用的指导原则：</p>
<ol>
<li>如果对 group by 语句的结果没有排序要求，要在语句后面加 order by null；</li>
<li>尽量让 group by 过程用上表的索引，确认方法是 explain 结果里没有 Using temporary 和 Using filesort；</li>
<li>如果 group by 需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大 tmp_table_size 参数，来避免用到磁盘临时表；</li>
<li>如果数据量实在太大，使用 SQL_BIG_RESULT 这个提示，来告诉优化器直接使用排序算法得到 group by 的结果。</li>
</ol>
<h2 id="38-都说InnoDB好，那还要不要使用Memory引擎？"><a href="#38-都说InnoDB好，那还要不要使用Memory引擎？" class="headerlink" title="38 | 都说InnoDB好，那还要不要使用Memory引擎？"></a>38 | 都说InnoDB好，那还要不要使用Memory引擎？</h2><h3 id="内存表的数据组织结构"><a href="#内存表的数据组织结构" class="headerlink" title="内存表的数据组织结构"></a>内存表的数据组织结构</h3><p>表 t1 使用 Memory 引擎， 表 t2 使用InnoDB 引擎。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(id <span class="type">int</span> <span class="keyword">primary</span> key, c <span class="type">int</span>) engine<span class="operator">=</span>Memory;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2(id <span class="type">int</span> <span class="keyword">primary</span> key, c <span class="type">int</span>) engine<span class="operator">=</span>innodb;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">8</span>),(<span class="number">9</span>,<span class="number">9</span>),(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">8</span>),(<span class="number">9</span>,<span class="number">9</span>),(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190323150235371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到两个引擎顺序不一致。<br>InnoDB 表的数据就放在主键索引树上，主键索引是 B+ 树。<br>与 InnoDB 引擎不同，Memory 引擎的数据和索引是分开的。<br><img src="https://img-blog.csdnimg.cn/20190323150623954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>内存表的数据部分以数组的方式单独存放，而主键 id 索引里，存的是每个数据的位置。主键 id 是 hash 索引，可以看到索引上的 key 并不是有序的。<br>在内存表 t1 中，执行 select * 按数组顺序全表扫描。因此，0 就是最后一个被读到。</p>
<p>所以InnoDB 和 Memory 引擎的数据组织方式是不同的：</p>
<ol>
<li>InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，我们称之为索引组织表（Index Organizied Table）。</li>
<li>Memory 引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为堆组织表（Heap Organizied Table）。</li>
</ol>
<p>两个引擎的一些典型不同：</p>
<ol>
<li>InnoDB 表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；</li>
<li>当数据文件有空洞的时候，InnoDB 表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值；</li>
<li>数据位置发生变化的时候，InnoDB 表只需要修改主键索引，而内存表需要修改所有索引；</li>
<li>InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。</li>
<li>InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。</li>
</ol>
<p>由于内存表的这些特性，每个数据行被删除以后，空出的这个位置都可以被接下来要插入的数据复用。<br>内存表 t1 的这个主键索引是哈希索引，因此如果执行范围查询是用不上主键索引的，需要走全表扫描。</p>
<h3 id="hash-索引和-B-Tree-索引"><a href="#hash-索引和-B-Tree-索引" class="headerlink" title="hash 索引和 B-Tree 索引"></a>hash 索引和 B-Tree 索引</h3><p>内存表也是支 B-Tree 索引的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> index a_btree_index <span class="keyword">using</span> btree (id);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190323155045583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="不建议你在生产环境上使用内存表"><a href="#不建议你在生产环境上使用内存表" class="headerlink" title="不建议你在生产环境上使用内存表"></a>不建议你在生产环境上使用内存表</h3><p>这里的原因主要包括两个方面：<br><strong>内存表的锁</strong><br>内存表不支持行锁，只支持表锁。<br><strong>数据持久性问题</strong><br>数据库重启的时候，所有的内存表都会被清空。<br>主从模式，从库掉电重启收到主库请求会找不到行。双主模式下，一台掉电重启会发送delete到另一台清空数据。</p>
<p>第 35 和 36 篇说到的用户临时表。在数据量可控，不会耗费过多内存的情况下，你可以考虑使用内存表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index (b))engine<span class="operator">=</span>memory;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">&lt;=</span><span class="number">2000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> temp_t <span class="keyword">on</span> (t1.b<span class="operator">=</span>temp_t.b);</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<h2 id="39-自增主键为什么不是连续的？"><a href="#39-自增主键为什么不是连续的？" class="headerlink" title="39 | 自增主键为什么不是连续的？"></a>39 | 自增主键为什么不是连续的？</h2><p>不同的引擎对于自增值的保存策略不同。</p>
<ul>
<li>MyISAM 引擎的自增值保存在数据文件中。</li>
<li>InnoDB 引擎保存在内存里，MySQL 8.0 版本后才有自增值持久化能力，记录在redo log中。MySQL 5.7 及之前的版本，每次重启后，第一次打开表的时候，都会去找自增值的最大值 max(id)，然后将 max(id)+1 作为这个表当前的自增值。</li>
</ul>
<h3 id="自增值修改机制"><a href="#自增值修改机制" class="headerlink" title="自增值修改机制"></a>自增值修改机制</h3><p>如果字段 id 被定义为 AUTO_INCREMENT</p>
<ol>
<li>如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；</li>
<li>如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。</li>
</ol>
<p>假设，某次要插入的值是 X，当前的自增值是 Y。</p>
<ol>
<li>如果 X&lt;Y，那么这个表的自增值不变；</li>
<li>如果&gt;=Y，就需要把当前自增值修改为新的自增值。</li>
</ol>
<p>新的自增值生成算法是：从 auto_increment_offset 开始，以 auto_increment_increment 为步长，持续叠加，直到找到第一个大于 X 的值，作为新的自增值。（双主架构可以设置一个库的自增id都是奇数，另一个都是偶数）。</p>
<h3 id="自增值的修改时机"><a href="#自增值的修改时机" class="headerlink" title="自增值的修改时机"></a>自增值的修改时机</h3><p>自增值会在插入数据之前自增。<br>所以唯一键冲突是导致自增主键 id 不连续的第一种原因。类似，事务回滚也会产生类似的现象。</p>
<h3 id="自增锁的优化"><a href="#自增锁的优化" class="headerlink" title="自增锁的优化"></a>自增锁的优化</h3><p>MySQL 5.1.22 版本引入了一个新策略，新增参数 innodb_autoinc_lock_mode，默认值是 1。</p>
<ol>
<li>0,语句执行结束后才释放锁；</li>
<li>1,普通 insert 语句，自增锁在申请之后就马上释放；类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li>
<li>这个参数的值被设置为 2 时，所有的申请自增主键的动作都是申请自增主键的动作都是申请后就释放锁。</li>
</ol>
<p>生产上，如果有insert … select、replace … select 和 load data 语句，这种批量插入数据的场景时，建议设置：innodb_autoinc_lock_mode=2 ，并且 binlog_format=row。<br>对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。所以如果多申请了id也会导致自增主键 id 不连续。</p>
<p>普通insert语句，即使 innodb_autoinc_lock_mode 设置为 1，也不会等语句执行完成才释放锁。因为在申请自增 id 的时候，是可以精确计算出需要多少个 id 的，然后一次性申请，申请完成后锁就可以释放了。</p>
<h2 id="40-insert语句的锁为什么这么多？"><a href="#40-insert语句的锁为什么这么多？" class="headerlink" title="40 | insert语句的锁为什么这么多？"></a>40 | insert语句的锁为什么这么多？</h2><h3 id="insert-…-select-语句"><a href="#insert-…-select-语句" class="headerlink" title="insert … select 语句"></a>insert … select 语句</h3><p>可重复读隔离级别下，binlog_format=statement。<br>表结构</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190330160223927.png" alt="在这里插入图片描述"><br>session B执行时需要对表 t 的所有行和间隙加锁。如果没有锁，就可能出现 session B 的 insert 语句先执行，但是后写入 binlog 的情况。所以会引起主备不一致。</p>
<h3 id="insert-循环写入"><a href="#insert-循环写入" class="headerlink" title="insert 循环写入"></a>insert 循环写入</h3><p>执行 insert … select 的时候，对目标表也不是锁全表，而是只锁住需要访问的资源。<br>现在有这么一个需求：要往表 t2 中插入一行数据，这一行的 c 值是表 t 中 c 值的最大值加 1。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d)  (<span class="keyword">select</span> c<span class="operator">+</span><span class="number">1</span>, d <span class="keyword">from</span> t force index(c) <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> limit <span class="number">1</span>);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这个语句的加锁范围，就是表 t 索引 c 上的 (3,4]和 (4,supremum] 这两个 next-key lock，以及主键索引上 id=4 这一行。<br>它的执行流程也比较简单，从表 t 中按照索引 c 倒序，扫描第一行，拿到结果写入到表 t2 中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c,d)  (<span class="keyword">select</span> c<span class="operator">+</span><span class="number">1</span>, d <span class="keyword">from</span> t force index(c) <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> limit <span class="number">1</span>);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如果执行这句sql，可以看到，这时候的 Rows_examined 的值是 5。并且使用了临时表。<br><img src="https://img-blog.csdnimg.cn/20190330161615294.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190330161650414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Explain 结果 rows=1 是因为受到了 limit 1 的影响。可能不准确。<br>使用执行Innodb_rows_read 语句查看查看sql执行前后扫描行数。<br><img src="https://img-blog.csdnimg.cn/20190330161906556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到，这个语句执行前后，Innodb_rows_read 的值增加了 4。因为默认临时表是使用 Memory 引擎的，所以这 4 行查的都是表 t，也就是说对表 t 做了全表扫描。<br>所以整个执行流程：</p>
<ol>
<li>创建临时表，表里有两个字段 c 和 d。</li>
<li>按照索引 c 扫描表 t，依次取 c=4、3、2、1，然后回表，读到 c 和 d 的值写入临时表。这时，Rows_examined=4。</li>
<li>由于语义里面有 limit 1，所以只取了临时表的第一行，再插入到表 t 中。这时，Rows_examined 的值加 1，变成了 5。</li>
</ol>
<p>这个语句会导致在表 t 上做全表扫描，并且会给索引 c 上的所有间隙都加上共享的 next-key lock。<br>这个语句的执行为什么需要临时表，原因是这类一边遍历数据，一边更新数据的情况，如果读出来的数据直接写回原表，就可能在遍历过程中，读到刚刚插入的记录，新插入的记录如果参与计算逻辑，就跟语义不符。<br>由于实现上这个语句没有在子查询中就直接使用 limit 1，从而导致了这个语句的执行需要遍历整个表 t。<br>优化方案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t(c <span class="type">int</span>,d <span class="type">int</span>) engine<span class="operator">=</span>memory;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t  (<span class="keyword">select</span> c<span class="operator">+</span><span class="number">1</span>, d <span class="keyword">from</span> t force index(c) <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> limit <span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> temp_t;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> temp_t;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<h3 id="insert-唯一键冲突"><a href="#insert-唯一键冲突" class="headerlink" title="insert 唯一键冲突"></a>insert 唯一键冲突</h3><p><img src="https://img-blog.csdnimg.cn/2019033016274258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>session A 执行的 insert 语句，发生唯一键冲突的时候，并不只是简单地报错返回，还在冲突的索引上加了锁。session A 持有索引 c 上的 (5,10] 共享 next-key lock（读锁）。<br>这个读锁作用上来看，这样做可以避免这一行被别的事务删掉。<br><img src="https://img-blog.csdnimg.cn/20190330162941977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>执行相同的 insert 语句，发现了唯一键冲突，加上读锁（Next-key lock）。session A 回滚，session B 和 session C 都试图继续执行插入操作，都要加上插入意向锁（LOCK_INSERT_INTENTION）。</p>
<h3 id="insert-into-…-on-duplicate-key-update"><a href="#insert-into-…-on-duplicate-key-update" class="headerlink" title="insert into … on duplicate key update"></a>insert into … on duplicate key update</h3><p>语义的逻辑是，插入一行数据，如果碰到唯一键约束，就执行后面的更新语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">11</span>,<span class="number">10</span>,<span class="number">10</span>) <span class="keyword">on</span> duplicate key update d<span class="operator">=</span><span class="number">100</span>; </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如果有多个列违反了唯一性约束，就会按照索引的顺序，修改跟第一个索引冲突的行。</p>
<h2 id="41-怎么最快地复制一张表？"><a href="#41-怎么最快地复制一张表？" class="headerlink" title="41 | 怎么最快地复制一张表？"></a>41 | 怎么最快地复制一张表？</h2><p>如果可以控制对源表的扫描行数和加锁范围很小的话，我们简单地使用 insert … select 语句即可实现。<br>表结构：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database db1;</span><br><span class="line">use db1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index(a))engine<span class="operator">=</span>innodb;</span><br><span class="line">delimiter ;;</span><br><span class="line">  <span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">    while(i<span class="operator">&lt;=</span><span class="number">1000</span>)do</span><br><span class="line">      <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i,i);</span><br><span class="line">      <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line">  <span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> database db2;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> db2.t <span class="keyword">like</span> db1.t</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure>

<h3 id="mysqldump-方法"><a href="#mysqldump-方法" class="headerlink" title="mysqldump 方法"></a>mysqldump 方法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>h$host <span class="operator">-</span>P$port <span class="operator">-</span>u$<span class="keyword">user</span> <span class="comment">--add-locks=0 --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where=&quot;a&gt;900&quot; --result-file=/client_tmp/t.sql</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>导出结果<br><img src="https://img-blog.csdnimg.cn/20190414131150949.png" alt="在这里插入图片描述"></p>
<h3 id="导出-CSV-文件"><a href="#导出-CSV-文件" class="headerlink" title="导出 CSV 文件"></a>导出 CSV 文件</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>导出</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> db1.t <span class="keyword">where</span> a<span class="operator">&gt;</span><span class="number">900</span> <span class="keyword">into</span> outfile <span class="string">&#x27;/server_tmp/t.csv&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>导入</span><br><span class="line">load data infile <span class="string">&#x27;/server_tmp/t.csv&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> db2.t;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<h3 id="物理拷贝方法"><a href="#物理拷贝方法" class="headerlink" title="物理拷贝方法"></a>物理拷贝方法</h3><p>在 MySQL 5.6 版本引入了可传输表空间(transportable tablespace) 的方法，可以通过导出 + 导入表空间的方式，实现物理拷贝表的功能。<br>假设我们现在的目标是在 db1 库下，复制一个跟表 t 相同的表 r：</p>
<ol>
<li>执行 create table r like t，创建一个相同表结构的空表；</li>
<li>执行 alter table r discard tablespace，这时候 r.ibd 文件会被删除；</li>
<li>执行 flush table t for export，这时候 db1 目录下会生成一个 t.cfg 文件；</li>
<li>在 db1 目录下执行 cp t.cfg r.cfg; cp t.ibd r.ibd；这两个命令；</li>
<li>执行 unlock tables，这时候 t.cfg 文件会被删除；</li>
<li>执行 alter table r import tablespace，将这个 r.ibd 文件作为表 r 的新的表空间，由于这个文件的数据内容和 t.ibd 是相同的，所以表 r 中就有了和表 t 相同的数据。</li>
</ol>
<h2 id="42-grant之后要跟着flush-privileges吗？"><a href="#42-grant之后要跟着flush-privileges吗？" class="headerlink" title="42 | grant之后要跟着flush privileges吗？"></a>42 | grant之后要跟着flush privileges吗？</h2><p>先创建一个用户：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;ua&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;pa&#x27;</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这条命令做了两个动作：</p>
<ol>
<li>磁盘上，往 mysql.user 表里插入一行，由于没有指定权限，所以这行数据上所有表示权限的字段的值都是 N；</li>
<li>内存里，往数组 acl_users 里插入一个 acl_user 对象，这个对象的 access 字段值为 0。</li>
</ol>
<h3 id="全局权限"><a href="#全局权限" class="headerlink" title="全局权限"></a>全局权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 增加权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;ua&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 取消权限</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;ua&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>将上述第1步权限字段的值 N 全改为 Y；把上述第2步内存数组 acl_users 全改为1。</p>
<h3 id="db-权限"><a href="#db-权限" class="headerlink" title="db 权限"></a>db 权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> db1.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;ua&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>grant 操作对于已经存在的连接的影响，在全局权限和基于 db 的权限效果是不同的。如果当前会话已经处于某一个 db 里面， use 这个库的时候拿到的库权限会保存在会话变量中，所以 revoke 会不生效。</p>
<h3 id="表权限和列权限"><a href="#表权限和列权限" class="headerlink" title="表权限和列权限"></a>表权限和列权限</h3><p>表权限定义存放在表 mysql.tables_priv 中，列权限定义存放在表 mysql.columns_priv 中。这两类权限，组合起来存放在内存的 hash 结构 column_priv_hash 中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> db1.t1(id <span class="type">int</span>, a <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> db1.t1 <span class="keyword">to</span> <span class="string">&#x27;ua&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>(id), <span class="keyword">INSERT</span> (id,a) <span class="keyword">ON</span> mydb.mytbl <span class="keyword">TO</span> <span class="string">&#x27;ua&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<h3 id="flush-privileges-使用场景"><a href="#flush-privileges-使用场景" class="headerlink" title="flush privileges 使用场景"></a>flush privileges 使用场景</h3><p>正常情况下，grant 命令之后，没有必要跟着执行 flush privileges 命令，因为会同时刷新内存数据。<br>但当数据表中的权限数据跟内存中的权限数据不一致的时候，flush privileges 语句可以用来重建内存数据，达到一致状态。这种不一致往往是由不规范的操作导致的，比如直接用 DML 语句操作系统权限表。</p>
<h2 id="43-要不要使用分区表？"><a href="#43-要不要使用分区表？" class="headerlink" title="43 | 要不要使用分区表？"></a>43 | 要不要使用分区表？</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `ftime` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  KEY (`ftime`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>latin1</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(ftime))</span><br><span class="line">(<span class="keyword">PARTITION</span> p_2017 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2017</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2018 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2018</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2019 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2019</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"><span class="keyword">PARTITION</span> p_others <span class="keyword">VALUES</span> LESS THAN MAXVALUE ENGINE <span class="operator">=</span> InnoDB);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="string">&#x27;2017-4-1&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;2018-4-1&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p>磁盘文件<br><img src="https://img-blog.csdnimg.cn/20190414142847821.png" alt="在这里插入图片描述"></p>
<ol>
<li>对于引擎层来说，这是 4 个表；</li>
<li>对于 Server 层来说，这是 1 个表。</li>
</ol>
<h3 id="分区表的引擎层行为"><a href="#分区表的引擎层行为" class="headerlink" title="分区表的引擎层行为"></a>分区表的引擎层行为</h3><p><img src="https://img-blog.csdnimg.cn/20190414143032307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190414143059107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于分区表的规则，session A 的 select 语句其实只操作了分区 p_2018。<br>如果是MyISAM则锁表p_2018 。</p>
<h3 id="手动分表和分区表有什么区别"><a href="#手动分表和分区表有什么区别" class="headerlink" title="手动分表和分区表有什么区别"></a>手动分表和分区表有什么区别</h3><p>分区表和手工分表，一个是由 server 层来决定使用哪个分区，一个是由应用层代码来决定使用哪个分表。因此，从引擎层看，这两种方式也是没有差别的。<br>主要区别在server 层上，分区表一个被广为诟病的问题：打开表的行为。</p>
<h3 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h3><p>MyISAM 引擎每当第一次访问一个分区表的时候，MySQL 需要把所有的分区都访问一遍。MySQL 启动的时候，open_files_limit 参数使用的是默认值 1024，如果超过上限将报错。InnoDB 引擎的话，并不会出现这个问题。</p>
<h3 id="分区表的-server-层行为"><a href="#分区表的-server-层行为" class="headerlink" title="分区表的 server 层行为"></a>分区表的 server 层行为</h3><p>如果从 server 层看的话，一个分区表就只是一个表。<br><img src="https://img-blog.csdnimg.cn/20190414144030343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>虽然 session B 只需要操作 p_2107 这个分区，但是由于 session A 持有整个表 t 的 MDL 锁，就导致了 session B 的 alter 语句被堵住。</p>
<h3 id="分区表的应用场景"><a href="#分区表的应用场景" class="headerlink" title="分区表的应用场景"></a>分区表的应用场景</h3><p>分区表的一个显而易见的优势是对业务透明，相对于用户分表来说，使用分区表的业务代码更简洁。还有，分区表可以很方便的清理历史数据。<br>按照时间分区的分区表，就可以直接通过 alter tablet drop partition …这个语法删掉分区，从而删掉过期的历史数据。</p>
<h3 id="44-答疑文章（三）：说一说这些好问题"><a href="#44-答疑文章（三）：说一说这些好问题" class="headerlink" title="44 | 答疑文章（三）：说一说这些好问题"></a>44 | 答疑文章（三）：说一说这些好问题</h3><h3 id="join-的写法"><a href="#join-的写法" class="headerlink" title="join 的写法"></a>join 的写法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> a(f1 <span class="type">int</span>, f2 <span class="type">int</span>, index(f1))engine<span class="operator">=</span>innodb;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> b(f1 <span class="type">int</span>, f2 <span class="type">int</span>)engine<span class="operator">=</span>innodb;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> a <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> b <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<ol>
<li>如果用 left join 的话，左边的表一定是驱动表吗？</li>
<li>如果两个表的 join 包含多个条件的等值匹配，是都要写到 on 里面呢，还是只把一个条件写到 on 里面，其他条件写到 where 部分？</li>
</ol>
<p>其实就是下面这两种写法的区别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">left</span> <span class="keyword">join</span> b <span class="keyword">on</span>(a.f1<span class="operator">=</span>b.f1) <span class="keyword">and</span> (a.f2<span class="operator">=</span>b.f2); <span class="comment">/*Q1*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">left</span> <span class="keyword">join</span> b <span class="keyword">on</span>(a.f1<span class="operator">=</span>b.f1) <span class="keyword">where</span> (a.f2<span class="operator">=</span>b.f2);<span class="comment">/*Q2*/</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190414145110368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Q1的explain：<br><img src="https://img-blog.csdnimg.cn/20190414145508626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Q1使用BNL算法，第 35 篇文章《join 语句怎么优化？》中讲过。<br>Q2的explain：<br><img src="https://img-blog.csdnimg.cn/20190414145756364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Q1使用NLJ算法，执行流程是这样的：顺序扫描表 b，每一行用 b.f1 到表 a 中去查，匹配到记录后判断 a.f2=b.f2 是否满足，满足条件的话就作为结果集的一部分返回。<br><strong>差别</strong><br>在 MySQL 里，NULL 跟任何值执行等值判断和不等值判断的结果，都是 NULL。所以 Q2 没有1和2。</p>
<p>Q2这条语句虽然用的是 left join，但是语义跟 join 是一致的。优化器会把Q2优化成join。因为表 a 的 f1 上有索引，就把表 b 作为驱动表，这样就可以用上 NLJ 算法。使用show warning;可以看到优化后的语句。<br><img src="https://img-blog.csdnimg.cn/20190414150329261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>所以使用 left join 时，<strong>左边的表不一定是驱动表</strong>。<br>如果需要 left join 的语义，就不能把被驱动表的字段放在 where 条件里面做等值判断或不等值判断，必须都写在 on 里面。</p>
<p>再来看两条sql：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">join</span> b <span class="keyword">on</span>(a.f1<span class="operator">=</span>b.f1) <span class="keyword">and</span> (a.f2<span class="operator">=</span>b.f2); <span class="comment">/*Q3*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">join</span> b <span class="keyword">on</span>(a.f1<span class="operator">=</span>b.f1) <span class="keyword">where</span> (a.f2<span class="operator">=</span>b.f2);<span class="comment">/*Q4*/</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190414152036281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在这种情况下，join 将判断条件是否全部放在 on 部分就没有区别了。</p>
<h3 id="Simple-Nested-Loop-Join-的性能问题"><a href="#Simple-Nested-Loop-Join-的性能问题" class="headerlink" title="Simple Nested Loop Join 的性能问题"></a>Simple Nested Loop Join 的性能问题</h3><p>Simple Nested Loop Join 算法，其实也是把数据读到内存里，然后按照匹配条件进行判断，为什么性能差距会这么大呢？<br>解释这个问题，需要用到 MySQL 中索引结构和 Buffer Pool 的相关知识点：</p>
<ol>
<li>在对被驱动表做全表扫描的时候，如果数据没有在 Buffer Pool 中，就需要等待这部分数据从磁盘读入；多次访问容易将这些数据页放到 Buffer Pool 的头部，影响 Buffer Pool 的命中率。</li>
<li>即使被驱动表数据都在内存中，每次查找“下一个记录的操作”，都是类似指针操作。而 join_buffer 中是数组，遍历的成本更低。</li>
</ol>
<h3 id="distinct-和-group-by-的性能"><a href="#distinct-和-group-by-的性能" class="headerlink" title="distinct 和 group by 的性能"></a>distinct 和 group by 的性能</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> t <span class="keyword">group</span> <span class="keyword">by</span> a <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> a <span class="keyword">from</span> t;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>group by 没有聚合函数，这两句sql的效率相同。</p>
<ol>
<li>创建一个临时表，临时表有一个字段 a，并且在这个字段 a 上创建一个唯一索引；</li>
<li>遍历表 t，依次取数据插入临时表中：如果发现唯一键冲突，就跳过；否则插入成功；</li>
<li>遍历完成后，将临时表作为结果集返回给客户端。</li>
</ol>
<h3 id="备库自增主键问题"><a href="#备库自增主键问题" class="headerlink" title="备库自增主键问题"></a>备库自增主键问题</h3><p>第 39 篇文章《自增主键为什么不是连续的？》评论区，@帽子掉了 同学问到：在 binlog_format=statement 时，语句 A 先获取 id=1，然后语句 B 获取 id=2；接着语句 B 提交，写 binlog，然后语句 A 再写 binlog。这时候，如果 binlog 重放，是不是会发生语句 B 的 id 为 1，而语句 A 的 id 为 2 的不一致情况呢？<br>不会，虽然 statement 格式下“自增 id 的生成顺序，和 binlog 的写入顺序可能是不同的”。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(id <span class="type">int</span> auto_increment <span class="keyword">primary</span> key);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>);</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190414160309689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>主库上语句 A 的 id 是 1，语句 B 的 id 是 2，但是写入 binlog 的顺序先 B 后 A，那么binlog 就变成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> INSERT_ID<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line">语句 B；</span><br><span class="line"><span class="keyword">SET</span> INSERT_ID<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">语句 A；</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<h2 id="45-自增id用完怎么办？"><a href="#45-自增id用完怎么办？" class="headerlink" title="45 | 自增id用完怎么办？"></a>45 | 自增id用完怎么办？</h2><h3 id="表定义自增值-id"><a href="#表定义自增值-id" class="headerlink" title="表定义自增值 id"></a>表定义自增值 id</h3><p>表定义的自增值达到上限后的逻辑是：再申请下一个 id 时，得到的值保持不变。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(id <span class="type">int</span> unsigned auto_increment <span class="keyword">primary</span> key) auto_increment<span class="operator">=</span><span class="number">4294967295</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 成功插入一行 <span class="number">4294967295</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t;</span><br><span class="line"><span class="comment">/* CREATE TABLE `t` (</span></span><br><span class="line"><span class="comment">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span></span><br><span class="line"><span class="comment">  PRIMARY KEY (`id`)</span></span><br><span class="line"><span class="comment">) ENGINE=InnoDB AUTO_INCREMENT=4294967295;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>Duplicate entry <span class="string">&#x27;4294967295&#x27;</span> <span class="keyword">for</span> key <span class="string">&#x27;PRIMARY&#x27;</span></span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<p>主键冲突，如果 4 个字节无符号整型 (unsigned int) 不够用的情况下，可以使用 8 个字节的 bigint unsigned。</p>
<h3 id="InnoDB-系统自增-row-id"><a href="#InnoDB-系统自增-row-id" class="headerlink" title="InnoDB 系统自增 row_id"></a>InnoDB 系统自增 row_id</h3><p>如果你创建的 InnoDB 表没有指定主键，那么 InnoDB 会给你创建一个不可见的，长度为 6 个字节的 row_id。InnoDB 维护了一个全局的 dict_sys.row_id 值，所有无主键的 InnoDB 表，每插入一行数据，都将当前的 dict_sys.row_id 值作为要插入数据的 row_id，然后把 dict_sys.row_id 的值加 1。<br>如果到达上限后，再有插入数据的行为要来申请 row_id，拿到以后再取最后 6 个字节的话就是 0，然后继续循环。所以会导致覆盖数据。</p>
<h3 id="Xid"><a href="#Xid" class="headerlink" title="Xid"></a>Xid</h3><p>redo log 和 binlog 相配合的时候，它们有一个共同的字段叫作 Xid。它在 MySQL 中是用来对应事务的。<br>MySQL 内部维护了一个全局变量 global_query_id，每次执行语句的时候将它赋值给 Query_id，然后给这个变量加 1。如果当前语句是这个事务执行的第一条语句，那么 MySQL 还会同时把 Query_id 赋值给这个事务的 Xid。<br>而 global_query_id 是一个纯内存变量，重启之后就清零了。所以你就知道了，在同一个数据库实例中，不同事务的 Xid 也是有可能相同的。但是 MySQL 重启之后会重新生成新的 binlog 文件，这就保证了，同一个 binlog 文件里，Xid 一定是唯一的。<br>不过 global_query_id 达到上限后，会继续从 0 开始计数，由于 global_query_id 为8个字节，所以一般不会出现到达上限的情况。</p>
<h3 id="Innodb-trx-id"><a href="#Innodb-trx-id" class="headerlink" title="Innodb trx_id"></a>Innodb trx_id</h3><p>Xid 是由 server 层维护的。InnoDB 内部使用 Xid ，就是为了能够在 InnoDB 事务和 server 之间做关联。但是，InnoDB 自己的 trx_id，是另外维护的。<br>InnoDB 内部维护了一个 max_trx_id 全局变量，每次需要申请一个新的 trx_id 时，就获得 max_trx_id 的当前值，然后并将 max_trx_id 加 1。<br>InnoDB 数据可见性的核心思想是：每一行数据都记录了更新它的 trx_id，当一个事务读到一行数据的时候，判断这个数据是否可见的方法，就是通过事务的一致性视图与这行数据的 trx_id 做对比。<br>对于正在执行的事务，你可以从 information_schema.innodb_trx 表中看到事务的 trx_id。<br>但是对于只读事务，InnoDB 并不会分配 trx_id。</p>
<p>max_trx_id 会持久化存储，重启也不会重置为 0，那么从理论上讲，只要一个 MySQL 服务跑得足够久，就可能到达上限，然后从 0 开始的情况。然后就会导致脏读。但只存在理论上，如果一个 MySQL 实例的 TPS 是每秒 50 万，持续这个压力的话，在 17.8 年后，就会出现这个情况。</p>
<h3 id="thread-id"><a href="#thread-id" class="headerlink" title="thread_id"></a>thread_id</h3><p>show processlist 里面的第一列，就是 thread_id。<br>系统保存了一个全局变量 thread_id_counter，每新建一个连接，就将 thread_id_counter 赋值给这个新连接的线程变量。<br>thread_id_counter 定义的大小是 4 个字节，到达上限则从0开始。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MySQL45%E8%AE%B2/" rel="tag"># MySQL45讲</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/mysql/mysql45-2/" rel="prev" title="「MySQL45讲」16-30讲">
      <i class="fa fa-chevron-left"></i> 「MySQL45讲」16-30讲
    </a></div>
      <div class="post-nav-item">
    <a href="/mysql/mysql45-%E6%80%BB%E7%BB%93/" rel="next" title="「MySQL45讲」个人总结">
      「MySQL45讲」个人总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#31-%E8%AF%AF%E5%88%A0%E6%95%B0%E6%8D%AE%E5%90%8E%E9%99%A4%E4%BA%86%E8%B7%91%E8%B7%AF%EF%BC%8C%E8%BF%98%E8%83%BD%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-text">31 | 误删数据后除了跑路，还能怎么办？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AF%E5%88%A0%E8%A1%8C"><span class="nav-text">误删行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AF%E5%88%A0%E5%BA%93-%E8%A1%A8"><span class="nav-text">误删库 &#x2F; 表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E5%A4%8D%E5%88%B6%E5%A4%87%E5%BA%93"><span class="nav-text">延迟复制备库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E6%9C%89kill%E4%B8%8D%E6%8E%89%E7%9A%84%E8%AF%AD%E5%8F%A5%EF%BC%9F"><span class="nav-text">32 | 为什么还有kill不掉的语句？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-%E6%88%91%E6%9F%A5%E8%BF%99%E4%B9%88%E5%A4%9A%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98%E6%89%93%E7%88%86%EF%BC%9F"><span class="nav-text">33 | 我查这么多数据，会不会把数据库内存打爆？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F%E5%AF%B9-server-%E5%B1%82%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-text">全表扫描对 server 层的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F%E5%AF%B9-InnoDB-%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-text">全表扫描对 InnoDB 的影响</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-%E5%88%B0%E5%BA%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8join%EF%BC%9F"><span class="nav-text">34 | 到底可不可以使用join？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Index-Nested-Loop-Join"><span class="nav-text">Index Nested-Loop Join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Simple-Nested-Loop-Join"><span class="nav-text">Simple Nested-Loop Join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Block-Nested-Loop-Join"><span class="nav-text">Block Nested-Loop Join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-join%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-text">35 | join语句怎么优化？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Multi-Range-Read-%E4%BC%98%E5%8C%96"><span class="nav-text">Multi-Range Read 优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Batched-Key-Access"><span class="nav-text">Batched Key Access</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BNL-%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-text">BNL 算法的性能问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95-hash-join"><span class="nav-text">扩展 -hash join</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D%EF%BC%9F"><span class="nav-text">36 | 为什么临时表可以重名？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">临时表的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D%EF%BC%9F"><span class="nav-text">为什么临时表可以重名？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%92%8C%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6"><span class="nav-text">临时表和主备复制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8%EF%BC%9F"><span class="nav-text">37 | 什么时候会使用内部临时表？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#group-by-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">group by 执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#group-by-%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95"><span class="nav-text">group by 优化方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-%E9%83%BD%E8%AF%B4InnoDB%E5%A5%BD%EF%BC%8C%E9%82%A3%E8%BF%98%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8Memory%E5%BC%95%E6%93%8E%EF%BC%9F"><span class="nav-text">38 | 都说InnoDB好，那还要不要使用Memory引擎？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="nav-text">内存表的数据组织结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash-%E7%B4%A2%E5%BC%95%E5%92%8C-B-Tree-%E7%B4%A2%E5%BC%95"><span class="nav-text">hash 索引和 B-Tree 索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%A0%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8A%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E8%A1%A8"><span class="nav-text">不建议你在生产环境上使用内存表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39-%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%EF%BC%9F"><span class="nav-text">39 | 自增主键为什么不是连续的？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%A2%9E%E5%80%BC%E4%BF%AE%E6%94%B9%E6%9C%BA%E5%88%B6"><span class="nav-text">自增值修改机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%A2%9E%E5%80%BC%E7%9A%84%E4%BF%AE%E6%94%B9%E6%97%B6%E6%9C%BA"><span class="nav-text">自增值的修改时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%A2%9E%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-text">自增锁的优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40-insert%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A%EF%BC%9F"><span class="nav-text">40 | insert语句的锁为什么这么多？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#insert-%E2%80%A6-select-%E8%AF%AD%E5%8F%A5"><span class="nav-text">insert … select 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#insert-%E5%BE%AA%E7%8E%AF%E5%86%99%E5%85%A5"><span class="nav-text">insert 循环写入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#insert-%E5%94%AF%E4%B8%80%E9%94%AE%E5%86%B2%E7%AA%81"><span class="nav-text">insert 唯一键冲突</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#insert-into-%E2%80%A6-on-duplicate-key-update"><span class="nav-text">insert into … on duplicate key update</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#41-%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8%EF%BC%9F"><span class="nav-text">41 | 怎么最快地复制一张表？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mysqldump-%E6%96%B9%E6%B3%95"><span class="nav-text">mysqldump 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%87%BA-CSV-%E6%96%87%E4%BB%B6"><span class="nav-text">导出 CSV 文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%95"><span class="nav-text">物理拷贝方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-grant%E4%B9%8B%E5%90%8E%E8%A6%81%E8%B7%9F%E7%9D%80flush-privileges%E5%90%97%EF%BC%9F"><span class="nav-text">42 | grant之后要跟着flush privileges吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E6%9D%83%E9%99%90"><span class="nav-text">全局权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#db-%E6%9D%83%E9%99%90"><span class="nav-text">db 权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E6%9D%83%E9%99%90%E5%92%8C%E5%88%97%E6%9D%83%E9%99%90"><span class="nav-text">表权限和列权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flush-privileges-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">flush privileges 使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8%EF%BC%9F"><span class="nav-text">43 | 要不要使用分区表？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E7%9A%84%E5%BC%95%E6%93%8E%E5%B1%82%E8%A1%8C%E4%B8%BA"><span class="nav-text">分区表的引擎层行为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E5%88%86%E8%A1%A8%E5%92%8C%E5%88%86%E5%8C%BA%E8%A1%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-text">手动分表和分区表有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5"><span class="nav-text">分区策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E7%9A%84-server-%E5%B1%82%E8%A1%8C%E4%B8%BA"><span class="nav-text">分区表的 server 层行为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">分区表的应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98"><span class="nav-text">44 | 答疑文章（三）：说一说这些好问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#join-%E7%9A%84%E5%86%99%E6%B3%95"><span class="nav-text">join 的写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Simple-Nested-Loop-Join-%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-text">Simple Nested Loop Join 的性能问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#distinct-%E5%92%8C-group-by-%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-text">distinct 和 group by 的性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%87%E5%BA%93%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E9%97%AE%E9%A2%98"><span class="nav-text">备库自增主键问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45-%E8%87%AA%E5%A2%9Eid%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-text">45 | 自增id用完怎么办？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E5%AE%9A%E4%B9%89%E8%87%AA%E5%A2%9E%E5%80%BC-id"><span class="nav-text">表定义自增值 id</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB-%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%A2%9E-row-id"><span class="nav-text">InnoDB 系统自增 row_id</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Xid"><span class="nav-text">Xid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Innodb-trx-id"><span class="nav-text">Innodb trx_id</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#thread-id"><span class="nav-text">thread_id</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Senkorl</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>
    
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
